<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Click: Element Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Click
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="class_element-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Element Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Base class for Click elements.  
 <a href="class_element.html#details">More...</a></p>

<p>Inherited by AddressInfo, AlignmentInfo, ErrorElement, Lexer::Compound, PortInfo, and ScheduleInfo.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element_1_1_port.html">Port</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="class_element.html" title="Base class for Click elements. ">Element</a>'s ports.  <a href="class_element_1_1_port.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af93e2bc4653d28caf99a7f293e63bb7c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>SELECT_READ</b> = 1, 
<b>SELECT_WRITE</b> = 2
 }</td></tr>
<tr class="separator:af93e2bc4653d28caf99a7f293e63bb7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae35e46e99ab46a307690e9697889df1a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>ConfigurePhase</b> { <br/>
&#160;&#160;<b>CONFIGURE_PHASE_FIRST</b> = 0, 
<b>CONFIGURE_PHASE_INFO</b> = 20, 
<b>CONFIGURE_PHASE_PRIVILEGED</b> = 90, 
<b>CONFIGURE_PHASE_DEFAULT</b> = 100, 
<br/>
&#160;&#160;<b>CONFIGURE_PHASE_LAST</b> = 2000
<br/>
 }</td></tr>
<tr class="separator:ae35e46e99ab46a307690e9697889df1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a155ab7dcea0e6f2078a300a502e68356"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>CleanupStage</b> { <br/>
&#160;&#160;<b>CLEANUP_NO_ROUTER</b>, 
<b>CLEANUP_BEFORE_CONFIGURE</b> = CLEANUP_NO_ROUTER, 
<b>CLEANUP_CONFIGURE_FAILED</b>, 
<b>CLEANUP_CONFIGURED</b>, 
<br/>
&#160;&#160;<b>CLEANUP_INITIALIZE_FAILED</b>, 
<b>CLEANUP_INITIALIZED</b>, 
<b>CLEANUP_ROUTER_INITIALIZED</b>, 
<b>CLEANUP_MANUAL</b>
<br/>
 }</td></tr>
<tr class="separator:a155ab7dcea0e6f2078a300a502e68356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a594122f999c63a878529cb16b4a479b3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br/>
&#160;&#160;<b>TASKHANDLER_WRITE_SCHEDULED</b> = 1, 
<b>TASKHANDLER_WRITE_TICKETS</b> = 2, 
<b>TASKHANDLER_WRITE_HOME_THREAD</b> = 4, 
<b>TASKHANDLER_WRITE_ALL</b> = 7, 
<br/>
&#160;&#160;<b>TASKHANDLER_DEFAULT</b> = 6
<br/>
 }</td></tr>
<tr class="separator:a594122f999c63a878529cb16b4a479b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab0d0e20be9a36ae676202db753faeec9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#ab0d0e20be9a36ae676202db753faeec9">Element</a> ()</td></tr>
<tr class="memdesc:ab0d0e20be9a36ae676202db753faeec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an <a class="el" href="class_element.html" title="Base class for Click elements. ">Element</a>.  <a href="#ab0d0e20be9a36ae676202db753faeec9">More...</a><br/></td></tr>
<tr class="separator:ab0d0e20be9a36ae676202db753faeec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af63395e97dd323b90d427e2eaae087eb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#af63395e97dd323b90d427e2eaae087eb">push</a> (int <a class="el" href="class_element.html#a397a2f89d50f1656b4d7c0334fa2747c">port</a>, <a class="el" href="class_packet.html">Packet</a> *p)</td></tr>
<tr class="memdesc:af63395e97dd323b90d427e2eaae087eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push packet <em>p</em> onto push input <em>port</em>.  <a href="#af63395e97dd323b90d427e2eaae087eb">More...</a><br/></td></tr>
<tr class="separator:af63395e97dd323b90d427e2eaae087eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8c7b8b37f177b9a9cc024d8b64f3a3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#ace8c7b8b37f177b9a9cc024d8b64f3a3">pull</a> (int <a class="el" href="class_element.html#a397a2f89d50f1656b4d7c0334fa2747c">port</a>)</td></tr>
<tr class="memdesc:ace8c7b8b37f177b9a9cc024d8b64f3a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pull a packet from pull output <em>port</em>.  <a href="#ace8c7b8b37f177b9a9cc024d8b64f3a3">More...</a><br/></td></tr>
<tr class="separator:ace8c7b8b37f177b9a9cc024d8b64f3a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dbe693607180d74bdbcd01110b77621"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#a8dbe693607180d74bdbcd01110b77621">simple_action</a> (<a class="el" href="class_packet.html">Packet</a> *p)</td></tr>
<tr class="memdesc:a8dbe693607180d74bdbcd01110b77621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process a packet for a simple packet filter.  <a href="#a8dbe693607180d74bdbcd01110b77621">More...</a><br/></td></tr>
<tr class="separator:a8dbe693607180d74bdbcd01110b77621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab40229beca000d06db59fd4720e319db"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#ab40229beca000d06db59fd4720e319db">run_task</a> (<a class="el" href="class_task.html">Task</a> *task)</td></tr>
<tr class="memdesc:ab40229beca000d06db59fd4720e319db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the element's task.  <a href="#ab40229beca000d06db59fd4720e319db">More...</a><br/></td></tr>
<tr class="separator:ab40229beca000d06db59fd4720e319db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adee431d2b975bc658e96e5ad98d30550"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#adee431d2b975bc658e96e5ad98d30550">run_timer</a> (<a class="el" href="class_timer.html">Timer</a> *timer)</td></tr>
<tr class="memdesc:adee431d2b975bc658e96e5ad98d30550"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the element's timer.  <a href="#adee431d2b975bc658e96e5ad98d30550">More...</a><br/></td></tr>
<tr class="separator:adee431d2b975bc658e96e5ad98d30550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa98e97859a6506f467fa6cb6a276c1f3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#aa98e97859a6506f467fa6cb6a276c1f3">selected</a> (int fd, int mask)</td></tr>
<tr class="memdesc:aa98e97859a6506f467fa6cb6a276c1f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle a file descriptor event.  <a href="#aa98e97859a6506f467fa6cb6a276c1f3">More...</a><br/></td></tr>
<tr class="separator:aa98e97859a6506f467fa6cb6a276c1f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e80acc32be82a8a77e443d83df5665f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#a9e80acc32be82a8a77e443d83df5665f">selected</a> (int fd)</td></tr>
<tr class="memdesc:a9e80acc32be82a8a77e443d83df5665f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle a file descriptor event.  <a href="#a9e80acc32be82a8a77e443d83df5665f">More...</a><br/></td></tr>
<tr class="separator:a9e80acc32be82a8a77e443d83df5665f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614ea4f79ad3f6cfd54f25a7df58d20e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#a614ea4f79ad3f6cfd54f25a7df58d20e">checked_output_push</a> (int <a class="el" href="class_element.html#a397a2f89d50f1656b4d7c0334fa2747c">port</a>, <a class="el" href="class_packet.html">Packet</a> *p) const </td></tr>
<tr class="memdesc:a614ea4f79ad3f6cfd54f25a7df58d20e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push packet <em>p</em> to output <em>port</em>, or kill it if <em>port</em> is out of range.  <a href="#a614ea4f79ad3f6cfd54f25a7df58d20e">More...</a><br/></td></tr>
<tr class="separator:a614ea4f79ad3f6cfd54f25a7df58d20e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ad83314087baddd651e9a4d7dd0000"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#ae6ad83314087baddd651e9a4d7dd0000">checked_input_pull</a> (int <a class="el" href="class_element.html#a397a2f89d50f1656b4d7c0334fa2747c">port</a>) const </td></tr>
<tr class="memdesc:ae6ad83314087baddd651e9a4d7dd0000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pull a packet from input <em>port</em>, or return 0 if <em>port</em> is out of range.  <a href="#ae6ad83314087baddd651e9a4d7dd0000">More...</a><br/></td></tr>
<tr class="separator:ae6ad83314087baddd651e9a4d7dd0000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8041b7068aea6830808a42afeddfcfd"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#ad8041b7068aea6830808a42afeddfcfd">class_name</a> () const =0</td></tr>
<tr class="memdesc:ad8041b7068aea6830808a42afeddfcfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the element's class name.  <a href="#ad8041b7068aea6830808a42afeddfcfd">More...</a><br/></td></tr>
<tr class="separator:ad8041b7068aea6830808a42afeddfcfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5b51c221451df6a3045f7e523c2e892"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#ae5b51c221451df6a3045f7e523c2e892">port_count</a> () const </td></tr>
<tr class="memdesc:ae5b51c221451df6a3045f7e523c2e892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the element's port count specifier.  <a href="#ae5b51c221451df6a3045f7e523c2e892">More...</a><br/></td></tr>
<tr class="separator:ae5b51c221451df6a3045f7e523c2e892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1fc03e194bd7b55481d55b9b41b751e"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#aa1fc03e194bd7b55481d55b9b41b751e">processing</a> () const </td></tr>
<tr class="memdesc:aa1fc03e194bd7b55481d55b9b41b751e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the element's processing specifier.  <a href="#aa1fc03e194bd7b55481d55b9b41b751e">More...</a><br/></td></tr>
<tr class="separator:aa1fc03e194bd7b55481d55b9b41b751e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb359ed32700d440149ba50cea37ae8b"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#acb359ed32700d440149ba50cea37ae8b">flow_code</a> () const </td></tr>
<tr class="memdesc:acb359ed32700d440149ba50cea37ae8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the element's internal packet flow specifier (its <em>flow code</em>).  <a href="#acb359ed32700d440149ba50cea37ae8b">More...</a><br/></td></tr>
<tr class="separator:acb359ed32700d440149ba50cea37ae8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3924d1c0d1e5fa7e856b20df02309a7"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#ac3924d1c0d1e5fa7e856b20df02309a7">flags</a> () const </td></tr>
<tr class="memdesc:ac3924d1c0d1e5fa7e856b20df02309a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the element's flags.  <a href="#ac3924d1c0d1e5fa7e856b20df02309a7">More...</a><br/></td></tr>
<tr class="separator:ac3924d1c0d1e5fa7e856b20df02309a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7c9264ebec07770222008dd553c8306"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#ab7c9264ebec07770222008dd553c8306">flag_value</a> (int flag) const </td></tr>
<tr class="memdesc:ab7c9264ebec07770222008dd553c8306"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the flag value for <em>flag</em> in <a class="el" href="class_element.html#ac3924d1c0d1e5fa7e856b20df02309a7" title="Return the element&#39;s flags. ">flags()</a>.  <a href="#ab7c9264ebec07770222008dd553c8306">More...</a><br/></td></tr>
<tr class="separator:ab7c9264ebec07770222008dd553c8306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae19904c6060f3d4411e32cba0dd2e3c1"><td class="memItemLeft" align="right" valign="top">virtual void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#ae19904c6060f3d4411e32cba0dd2e3c1">cast</a> (const char *<a class="el" href="class_element.html#ae9d788e790a336314f3525cb4e635c1a">name</a>)</td></tr>
<tr class="memdesc:ae19904c6060f3d4411e32cba0dd2e3c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to cast the element to a named type.  <a href="#ae19904c6060f3d4411e32cba0dd2e3c1">More...</a><br/></td></tr>
<tr class="separator:ae19904c6060f3d4411e32cba0dd2e3c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea5fabef78987e9e6762d53e636739a"><td class="memItemLeft" align="right" valign="top">virtual void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#a8ea5fabef78987e9e6762d53e636739a">port_cast</a> (bool isoutput, int <a class="el" href="class_element.html#a397a2f89d50f1656b4d7c0334fa2747c">port</a>, const char *<a class="el" href="class_element.html#ae9d788e790a336314f3525cb4e635c1a">name</a>)</td></tr>
<tr class="memdesc:a8ea5fabef78987e9e6762d53e636739a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to cast an element's port to a named type.  <a href="#a8ea5fabef78987e9e6762d53e636739a">More...</a><br/></td></tr>
<tr class="separator:a8ea5fabef78987e9e6762d53e636739a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e6b1d114dfacf402fe5066ec0f3cf92"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#a1e6b1d114dfacf402fe5066ec0f3cf92">configure_phase</a> () const </td></tr>
<tr class="memdesc:a1e6b1d114dfacf402fe5066ec0f3cf92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the element's configure phase, which determines the order in which elements are configured and initialized.  <a href="#a1e6b1d114dfacf402fe5066ec0f3cf92">More...</a><br/></td></tr>
<tr class="separator:a1e6b1d114dfacf402fe5066ec0f3cf92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2bb58f562728df47d007fd12a9e92f4"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#ab2bb58f562728df47d007fd12a9e92f4">configure</a> (<a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="class_string.html">String</a> &gt; &amp;conf, <a class="el" href="class_error_handler.html">ErrorHandler</a> *errh)</td></tr>
<tr class="memdesc:ab2bb58f562728df47d007fd12a9e92f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the element's configuration arguments.  <a href="#ab2bb58f562728df47d007fd12a9e92f4">More...</a><br/></td></tr>
<tr class="separator:ab2bb58f562728df47d007fd12a9e92f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a2efbc7c6af095d16cf31015e9216f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#a65a2efbc7c6af095d16cf31015e9216f">add_handlers</a> ()</td></tr>
<tr class="memdesc:a65a2efbc7c6af095d16cf31015e9216f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install the element's handlers.  <a href="#a65a2efbc7c6af095d16cf31015e9216f">More...</a><br/></td></tr>
<tr class="separator:a65a2efbc7c6af095d16cf31015e9216f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf2bbb7d3ae5a1372a6af9d7bb8269fe"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#abf2bbb7d3ae5a1372a6af9d7bb8269fe">initialize</a> (<a class="el" href="class_error_handler.html">ErrorHandler</a> *errh)</td></tr>
<tr class="memdesc:abf2bbb7d3ae5a1372a6af9d7bb8269fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the element.  <a href="#abf2bbb7d3ae5a1372a6af9d7bb8269fe">More...</a><br/></td></tr>
<tr class="separator:abf2bbb7d3ae5a1372a6af9d7bb8269fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf80c057f2d850ac85de15e22d58c52"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#abbf80c057f2d850ac85de15e22d58c52">take_state</a> (<a class="el" href="class_element.html">Element</a> *old_element, <a class="el" href="class_error_handler.html">ErrorHandler</a> *errh)</td></tr>
<tr class="memdesc:abbf80c057f2d850ac85de15e22d58c52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the element for hotswap, where the element should take <em>old_element's</em> state, if possible.  <a href="#abbf80c057f2d850ac85de15e22d58c52">More...</a><br/></td></tr>
<tr class="separator:abbf80c057f2d850ac85de15e22d58c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde7f3dce9335145efd79c0d77527768"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_element.html">Element</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#afde7f3dce9335145efd79c0d77527768">hotswap_element</a> () const </td></tr>
<tr class="memdesc:afde7f3dce9335145efd79c0d77527768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a compatible element in the hotswap router.  <a href="#afde7f3dce9335145efd79c0d77527768">More...</a><br/></td></tr>
<tr class="separator:afde7f3dce9335145efd79c0d77527768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa58cba2310e9207a8afa1c5f4ecfc878"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#aa58cba2310e9207a8afa1c5f4ecfc878">cleanup</a> (CleanupStage stage)</td></tr>
<tr class="memdesc:aa58cba2310e9207a8afa1c5f4ecfc878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean up the element's state.  <a href="#aa58cba2310e9207a8afa1c5f4ecfc878">More...</a><br/></td></tr>
<tr class="separator:aa58cba2310e9207a8afa1c5f4ecfc878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d788e790a336314f3525cb4e635c1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_string.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#ae9d788e790a336314f3525cb4e635c1a">name</a> () const </td></tr>
<tr class="memdesc:ae9d788e790a336314f3525cb4e635c1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the element's name.  <a href="#ae9d788e790a336314f3525cb4e635c1a">More...</a><br/></td></tr>
<tr class="separator:ae9d788e790a336314f3525cb4e635c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d638cc353699177a9e5c06634cd5a56"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_string.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#a1d638cc353699177a9e5c06634cd5a56">declaration</a> () const </td></tr>
<tr class="memdesc:a1d638cc353699177a9e5c06634cd5a56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a string giving the element's name and class name.  <a href="#a1d638cc353699177a9e5c06634cd5a56">More...</a><br/></td></tr>
<tr class="separator:a1d638cc353699177a9e5c06634cd5a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcf3d3b03e6f24495dc92234376a7be4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_router.html">Router</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#afcf3d3b03e6f24495dc92234376a7be4">router</a> () const </td></tr>
<tr class="memdesc:afcf3d3b03e6f24495dc92234376a7be4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the element's router.  <a href="#afcf3d3b03e6f24495dc92234376a7be4">More...</a><br/></td></tr>
<tr class="separator:afcf3d3b03e6f24495dc92234376a7be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f6ee27e9342386aaa3cb5381615cd5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#ae9f6ee27e9342386aaa3cb5381615cd5">eindex</a> () const </td></tr>
<tr class="memdesc:ae9f6ee27e9342386aaa3cb5381615cd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the element's index within its router.  <a href="#ae9f6ee27e9342386aaa3cb5381615cd5">More...</a><br/></td></tr>
<tr class="separator:ae9f6ee27e9342386aaa3cb5381615cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ea95b2e912d7d0275ddcf8d564c0644"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#a2ea95b2e912d7d0275ddcf8d564c0644">eindex</a> (<a class="el" href="class_router.html">Router</a> *r) const </td></tr>
<tr class="memdesc:a2ea95b2e912d7d0275ddcf8d564c0644"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the element's index within router <em>r</em>.  <a href="#a2ea95b2e912d7d0275ddcf8d564c0644">More...</a><br/></td></tr>
<tr class="separator:a2ea95b2e912d7d0275ddcf8d564c0644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7526dd9b470aa8c31ce3da9d00868d81"><td class="memItemLeft" align="right" valign="top">Master *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#a7526dd9b470aa8c31ce3da9d00868d81">master</a> () const </td></tr>
<tr class="memdesc:a7526dd9b470aa8c31ce3da9d00868d81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the element's master.  <a href="#a7526dd9b470aa8c31ce3da9d00868d81">More...</a><br/></td></tr>
<tr class="separator:a7526dd9b470aa8c31ce3da9d00868d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a268594094c05e04ea39321e64b49fd2c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a268594094c05e04ea39321e64b49fd2c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>attach_router</b> (<a class="el" href="class_router.html">Router</a> *r, int <a class="el" href="class_element.html#ae9f6ee27e9342386aaa3cb5381615cd5">eindex</a>)</td></tr>
<tr class="separator:a268594094c05e04ea39321e64b49fd2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0223195c4a2b7385a0590343ef61557f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#a0223195c4a2b7385a0590343ef61557f">nports</a> (bool isoutput) const </td></tr>
<tr class="memdesc:a0223195c4a2b7385a0590343ef61557f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of input or output ports.  <a href="#a0223195c4a2b7385a0590343ef61557f">More...</a><br/></td></tr>
<tr class="separator:a0223195c4a2b7385a0590343ef61557f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05eb1531f95eff14e04229eb29c5b50b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#a05eb1531f95eff14e04229eb29c5b50b">ninputs</a> () const </td></tr>
<tr class="memdesc:a05eb1531f95eff14e04229eb29c5b50b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of input ports.  <a href="#a05eb1531f95eff14e04229eb29c5b50b">More...</a><br/></td></tr>
<tr class="separator:a05eb1531f95eff14e04229eb29c5b50b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b909f7829ff14f5b1dd4165580f69f8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#a3b909f7829ff14f5b1dd4165580f69f8">noutputs</a> () const </td></tr>
<tr class="memdesc:a3b909f7829ff14f5b1dd4165580f69f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of output ports.  <a href="#a3b909f7829ff14f5b1dd4165580f69f8">More...</a><br/></td></tr>
<tr class="separator:a3b909f7829ff14f5b1dd4165580f69f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a397a2f89d50f1656b4d7c0334fa2747c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_element_1_1_port.html">Port</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#a397a2f89d50f1656b4d7c0334fa2747c">port</a> (bool isoutput, int port) const </td></tr>
<tr class="memdesc:a397a2f89d50f1656b4d7c0334fa2747c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return one of the element's ports.  <a href="#a397a2f89d50f1656b4d7c0334fa2747c">More...</a><br/></td></tr>
<tr class="separator:a397a2f89d50f1656b4d7c0334fa2747c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a526e36b67e098181d2b3232193427b27"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_element_1_1_port.html">Port</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#a526e36b67e098181d2b3232193427b27">input</a> (int <a class="el" href="class_element.html#a397a2f89d50f1656b4d7c0334fa2747c">port</a>) const </td></tr>
<tr class="memdesc:a526e36b67e098181d2b3232193427b27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return one of the element's input ports.  <a href="#a526e36b67e098181d2b3232193427b27">More...</a><br/></td></tr>
<tr class="separator:a526e36b67e098181d2b3232193427b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b3d622841bb29ee99da17ddba88a471"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_element_1_1_port.html">Port</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#a3b3d622841bb29ee99da17ddba88a471">output</a> (int <a class="el" href="class_element.html#a397a2f89d50f1656b4d7c0334fa2747c">port</a>) const </td></tr>
<tr class="memdesc:a3b3d622841bb29ee99da17ddba88a471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return one of the element's output ports.  <a href="#a3b3d622841bb29ee99da17ddba88a471">More...</a><br/></td></tr>
<tr class="separator:a3b3d622841bb29ee99da17ddba88a471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38a57625b6c72bef7d3372d0cbb1340e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#a38a57625b6c72bef7d3372d0cbb1340e">port_active</a> (bool isoutput, int <a class="el" href="class_element.html#a397a2f89d50f1656b4d7c0334fa2747c">port</a>) const </td></tr>
<tr class="memdesc:a38a57625b6c72bef7d3372d0cbb1340e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a port is active.  <a href="#a38a57625b6c72bef7d3372d0cbb1340e">More...</a><br/></td></tr>
<tr class="separator:a38a57625b6c72bef7d3372d0cbb1340e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a008593f424c28ff3383f48171a55f9aa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#a008593f424c28ff3383f48171a55f9aa">input_is_push</a> (int <a class="el" href="class_element.html#a397a2f89d50f1656b4d7c0334fa2747c">port</a>) const </td></tr>
<tr class="memdesc:a008593f424c28ff3383f48171a55f9aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether input <em>port</em> is push.  <a href="#a008593f424c28ff3383f48171a55f9aa">More...</a><br/></td></tr>
<tr class="separator:a008593f424c28ff3383f48171a55f9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc88cf11558b6c2c020169c264f2a9d8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#adc88cf11558b6c2c020169c264f2a9d8">input_is_pull</a> (int <a class="el" href="class_element.html#a397a2f89d50f1656b4d7c0334fa2747c">port</a>) const </td></tr>
<tr class="memdesc:adc88cf11558b6c2c020169c264f2a9d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether input <em>port</em> is pull.  <a href="#adc88cf11558b6c2c020169c264f2a9d8">More...</a><br/></td></tr>
<tr class="separator:adc88cf11558b6c2c020169c264f2a9d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d7fcf6ec9c04da9ed44944cad797906"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#a5d7fcf6ec9c04da9ed44944cad797906">output_is_push</a> (int <a class="el" href="class_element.html#a397a2f89d50f1656b4d7c0334fa2747c">port</a>) const </td></tr>
<tr class="memdesc:a5d7fcf6ec9c04da9ed44944cad797906"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether output <em>port</em> is push.  <a href="#a5d7fcf6ec9c04da9ed44944cad797906">More...</a><br/></td></tr>
<tr class="separator:a5d7fcf6ec9c04da9ed44944cad797906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5f05a099134956c439e0dbd9185b882"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#ae5f05a099134956c439e0dbd9185b882">output_is_pull</a> (int <a class="el" href="class_element.html#a397a2f89d50f1656b4d7c0334fa2747c">port</a>) const </td></tr>
<tr class="memdesc:ae5f05a099134956c439e0dbd9185b882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether output <em>port</em> is pull.  <a href="#ae5f05a099134956c439e0dbd9185b882">More...</a><br/></td></tr>
<tr class="separator:ae5f05a099134956c439e0dbd9185b882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea87a4b450501ba8bde14d4431ea7e92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#aea87a4b450501ba8bde14d4431ea7e92">port_flow</a> (bool isoutput, int <a class="el" href="class_element.html#a397a2f89d50f1656b4d7c0334fa2747c">port</a>, <a class="el" href="class_bitvector.html">Bitvector</a> *) const </td></tr>
<tr class="memdesc:aea87a4b450501ba8bde14d4431ea7e92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyze internal packet flow with respect to port <em>p</em>.  <a href="#aea87a4b450501ba8bde14d4431ea7e92">More...</a><br/></td></tr>
<tr class="separator:aea87a4b450501ba8bde14d4431ea7e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c909e3f64f1104e0c70a5acc53166a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_string.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#a4c909e3f64f1104e0c70a5acc53166a0">configuration</a> () const </td></tr>
<tr class="memdesc:a4c909e3f64f1104e0c70a5acc53166a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the element's current configuration string.  <a href="#a4c909e3f64f1104e0c70a5acc53166a0">More...</a><br/></td></tr>
<tr class="separator:a4c909e3f64f1104e0c70a5acc53166a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea3e2211f7024e49d4120ed7734f5fa9"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#aea3e2211f7024e49d4120ed7734f5fa9">can_live_reconfigure</a> () const </td></tr>
<tr class="memdesc:aea3e2211f7024e49d4120ed7734f5fa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether an element supports live reconfiguration.  <a href="#aea3e2211f7024e49d4120ed7734f5fa9">More...</a><br/></td></tr>
<tr class="separator:aea3e2211f7024e49d4120ed7734f5fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56db8a2641022efc353efed36fdd73f1"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#a56db8a2641022efc353efed36fdd73f1">live_reconfigure</a> (<a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="class_string.html">String</a> &gt; &amp;, <a class="el" href="class_error_handler.html">ErrorHandler</a> *)</td></tr>
<tr class="memdesc:a56db8a2641022efc353efed36fdd73f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconfigure the element while the router is running.  <a href="#a56db8a2641022efc353efed36fdd73f1">More...</a><br/></td></tr>
<tr class="separator:a56db8a2641022efc353efed36fdd73f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a941698f9fa2b91f6e795a05497e18b49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_router_thread.html">RouterThread</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#a941698f9fa2b91f6e795a05497e18b49">home_thread</a> () const </td></tr>
<tr class="memdesc:a941698f9fa2b91f6e795a05497e18b49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the element's home thread.  <a href="#a941698f9fa2b91f6e795a05497e18b49">More...</a><br/></td></tr>
<tr class="separator:a941698f9fa2b91f6e795a05497e18b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed6015f3a12301042b6abcdcc6d082d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#a7ed6015f3a12301042b6abcdcc6d082d">add_select</a> (int fd, int mask)</td></tr>
<tr class="memdesc:a7ed6015f3a12301042b6abcdcc6d082d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register interest in <em>mask</em> events on file descriptor <em>fd</em>.  <a href="#a7ed6015f3a12301042b6abcdcc6d082d">More...</a><br/></td></tr>
<tr class="separator:a7ed6015f3a12301042b6abcdcc6d082d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c789f9051b016234f5f6c02dc8243fa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#a7c789f9051b016234f5f6c02dc8243fa">remove_select</a> (int fd, int mask)</td></tr>
<tr class="memdesc:a7c789f9051b016234f5f6c02dc8243fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove interest in <em>mask</em> events on file descriptor <em>fd</em>.  <a href="#a7c789f9051b016234f5f6c02dc8243fa">More...</a><br/></td></tr>
<tr class="separator:a7c789f9051b016234f5f6c02dc8243fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17b61e50a0d5c87f77606f673fe1a553"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#a17b61e50a0d5c87f77606f673fe1a553">add_read_handler</a> (const <a class="el" href="class_string.html">String</a> &amp;<a class="el" href="class_element.html#ae9d788e790a336314f3525cb4e635c1a">name</a>, ReadHandlerCallback read_callback, const void *user_data=0, uint32_t <a class="el" href="class_element.html#ac3924d1c0d1e5fa7e856b20df02309a7">flags</a>=0)</td></tr>
<tr class="memdesc:a17b61e50a0d5c87f77606f673fe1a553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a read handler named <em>name</em>.  <a href="#a17b61e50a0d5c87f77606f673fe1a553">More...</a><br/></td></tr>
<tr class="separator:a17b61e50a0d5c87f77606f673fe1a553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c183575db52b821054a8e1d36383695"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#a3c183575db52b821054a8e1d36383695">add_read_handler</a> (const <a class="el" href="class_string.html">String</a> &amp;<a class="el" href="class_element.html#ae9d788e790a336314f3525cb4e635c1a">name</a>, ReadHandlerCallback read_callback, int user_data, uint32_t <a class="el" href="class_element.html#ac3924d1c0d1e5fa7e856b20df02309a7">flags</a>=0)</td></tr>
<tr class="memdesc:a3c183575db52b821054a8e1d36383695"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a read handler named <em>name</em>.  <a href="#a3c183575db52b821054a8e1d36383695">More...</a><br/></td></tr>
<tr class="separator:a3c183575db52b821054a8e1d36383695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0dd551b17d084eb0665f135f11a0ae5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#ae0dd551b17d084eb0665f135f11a0ae5">add_read_handler</a> (const char *<a class="el" href="class_element.html#ae9d788e790a336314f3525cb4e635c1a">name</a>, ReadHandlerCallback read_callback, int user_data=0, uint32_t <a class="el" href="class_element.html#ac3924d1c0d1e5fa7e856b20df02309a7">flags</a>=0)</td></tr>
<tr class="memdesc:ae0dd551b17d084eb0665f135f11a0ae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a read handler named <em>name</em>.  <a href="#ae0dd551b17d084eb0665f135f11a0ae5">More...</a><br/></td></tr>
<tr class="separator:ae0dd551b17d084eb0665f135f11a0ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a277b48d1711b54532762f456b8a61218"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#a277b48d1711b54532762f456b8a61218">add_write_handler</a> (const <a class="el" href="class_string.html">String</a> &amp;<a class="el" href="class_element.html#ae9d788e790a336314f3525cb4e635c1a">name</a>, WriteHandlerCallback write_callback, const void *user_data=0, uint32_t <a class="el" href="class_element.html#ac3924d1c0d1e5fa7e856b20df02309a7">flags</a>=0)</td></tr>
<tr class="memdesc:a277b48d1711b54532762f456b8a61218"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a write handler named <em>name</em>.  <a href="#a277b48d1711b54532762f456b8a61218">More...</a><br/></td></tr>
<tr class="separator:a277b48d1711b54532762f456b8a61218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a458209eff42e3a8cf2ac228f6ac23104"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#a458209eff42e3a8cf2ac228f6ac23104">add_write_handler</a> (const <a class="el" href="class_string.html">String</a> &amp;<a class="el" href="class_element.html#ae9d788e790a336314f3525cb4e635c1a">name</a>, WriteHandlerCallback write_callback, int user_data, uint32_t <a class="el" href="class_element.html#ac3924d1c0d1e5fa7e856b20df02309a7">flags</a>=0)</td></tr>
<tr class="memdesc:a458209eff42e3a8cf2ac228f6ac23104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a write handler named <em>name</em>.  <a href="#a458209eff42e3a8cf2ac228f6ac23104">More...</a><br/></td></tr>
<tr class="separator:a458209eff42e3a8cf2ac228f6ac23104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a166c05b2674d0eedfdf187690d6a8dd9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#a166c05b2674d0eedfdf187690d6a8dd9">add_write_handler</a> (const char *<a class="el" href="class_element.html#ae9d788e790a336314f3525cb4e635c1a">name</a>, WriteHandlerCallback write_callback, int user_data=0, uint32_t <a class="el" href="class_element.html#ac3924d1c0d1e5fa7e856b20df02309a7">flags</a>=0)</td></tr>
<tr class="memdesc:a166c05b2674d0eedfdf187690d6a8dd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a write handler named <em>name</em>.  <a href="#a166c05b2674d0eedfdf187690d6a8dd9">More...</a><br/></td></tr>
<tr class="separator:a166c05b2674d0eedfdf187690d6a8dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d54fb72aa3547cfa3095077dbdfa89c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#a1d54fb72aa3547cfa3095077dbdfa89c">set_handler</a> (const <a class="el" href="class_string.html">String</a> &amp;<a class="el" href="class_element.html#ae9d788e790a336314f3525cb4e635c1a">name</a>, int <a class="el" href="class_element.html#ac3924d1c0d1e5fa7e856b20df02309a7">flags</a>, HandlerCallback callback, const void *read_user_data=0, const void *write_user_data=0)</td></tr>
<tr class="memdesc:a1d54fb72aa3547cfa3095077dbdfa89c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a comprehensive handler named <em>name</em>.  <a href="#a1d54fb72aa3547cfa3095077dbdfa89c">More...</a><br/></td></tr>
<tr class="separator:a1d54fb72aa3547cfa3095077dbdfa89c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace0cebeb4e2fb6c105292ce44e7d191f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#ace0cebeb4e2fb6c105292ce44e7d191f">set_handler</a> (const <a class="el" href="class_string.html">String</a> &amp;<a class="el" href="class_element.html#ae9d788e790a336314f3525cb4e635c1a">name</a>, int <a class="el" href="class_element.html#ac3924d1c0d1e5fa7e856b20df02309a7">flags</a>, HandlerCallback callback, int read_user_data, int write_user_data=0)</td></tr>
<tr class="memdesc:ace0cebeb4e2fb6c105292ce44e7d191f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a comprehensive handler named <em>name</em>.  <a href="#ace0cebeb4e2fb6c105292ce44e7d191f">More...</a><br/></td></tr>
<tr class="separator:ace0cebeb4e2fb6c105292ce44e7d191f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af60c267d804237970b7066fd51abaef3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#af60c267d804237970b7066fd51abaef3">set_handler</a> (const char *<a class="el" href="class_element.html#ae9d788e790a336314f3525cb4e635c1a">name</a>, int <a class="el" href="class_element.html#ac3924d1c0d1e5fa7e856b20df02309a7">flags</a>, HandlerCallback callback, int read_user_data=0, int write_user_data=0)</td></tr>
<tr class="memdesc:af60c267d804237970b7066fd51abaef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a comprehensive handler named <em>name</em>.  <a href="#af60c267d804237970b7066fd51abaef3">More...</a><br/></td></tr>
<tr class="separator:af60c267d804237970b7066fd51abaef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eca02ee2bbc0c5c0b031cc542da234c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#a8eca02ee2bbc0c5c0b031cc542da234c">set_handler_flags</a> (const <a class="el" href="class_string.html">String</a> &amp;<a class="el" href="class_element.html#ae9d788e790a336314f3525cb4e635c1a">name</a>, int set_flags, int clear_flags=0)</td></tr>
<tr class="memdesc:a8eca02ee2bbc0c5c0b031cc542da234c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set flags for the handler named <em>name</em>.  <a href="#a8eca02ee2bbc0c5c0b031cc542da234c">More...</a><br/></td></tr>
<tr class="separator:a8eca02ee2bbc0c5c0b031cc542da234c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedbde0bd1c9397f4298334052a994abe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#aedbde0bd1c9397f4298334052a994abe">add_task_handlers</a> (<a class="el" href="class_task.html">Task</a> *task, <a class="el" href="class_notifier_signal.html">NotifierSignal</a> *signal, int <a class="el" href="class_element.html#ac3924d1c0d1e5fa7e856b20df02309a7">flags</a>, const <a class="el" href="class_string.html">String</a> &amp;prefix=<a class="el" href="class_string.html">String</a>())</td></tr>
<tr class="memdesc:aedbde0bd1c9397f4298334052a994abe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register handlers for a task.  <a href="#aedbde0bd1c9397f4298334052a994abe">More...</a><br/></td></tr>
<tr class="separator:aedbde0bd1c9397f4298334052a994abe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb08de21f8f484102f060371ae89deb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3eb08de21f8f484102f060371ae89deb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>add_task_handlers</b> (<a class="el" href="class_task.html">Task</a> *task, <a class="el" href="class_notifier_signal.html">NotifierSignal</a> *signal, const <a class="el" href="class_string.html">String</a> &amp;prefix=<a class="el" href="class_string.html">String</a>())</td></tr>
<tr class="separator:a3eb08de21f8f484102f060371ae89deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d22931af7e7935e03ca2e52d51f2a75"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7d22931af7e7935e03ca2e52d51f2a75"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>add_task_handlers</b> (<a class="el" href="class_task.html">Task</a> *task, const <a class="el" href="class_string.html">String</a> &amp;prefix=<a class="el" href="class_string.html">String</a>())</td></tr>
<tr class="separator:a7d22931af7e7935e03ca2e52d51f2a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a837de440df86cf088e14142ecb1b26c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#a837de440df86cf088e14142ecb1b26c7">add_data_handlers</a> (const char *<a class="el" href="class_element.html#ae9d788e790a336314f3525cb4e635c1a">name</a>, int <a class="el" href="class_element.html#ac3924d1c0d1e5fa7e856b20df02309a7">flags</a>, uint8_t *data)</td></tr>
<tr class="memdesc:a837de440df86cf088e14142ecb1b26c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register read and/or write handlers accessing <em>data</em>.  <a href="#a837de440df86cf088e14142ecb1b26c7">More...</a><br/></td></tr>
<tr class="separator:a837de440df86cf088e14142ecb1b26c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe3c05c39e6011878b97fb695e26e89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#aafe3c05c39e6011878b97fb695e26e89">add_data_handlers</a> (const char *<a class="el" href="class_element.html#ae9d788e790a336314f3525cb4e635c1a">name</a>, int <a class="el" href="class_element.html#ac3924d1c0d1e5fa7e856b20df02309a7">flags</a>, bool *data)</td></tr>
<tr class="separator:aafe3c05c39e6011878b97fb695e26e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a918dbca1f74786143db5ce22ba36dae5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#a918dbca1f74786143db5ce22ba36dae5">add_data_handlers</a> (const char *<a class="el" href="class_element.html#ae9d788e790a336314f3525cb4e635c1a">name</a>, int <a class="el" href="class_element.html#ac3924d1c0d1e5fa7e856b20df02309a7">flags</a>, uint16_t *data)</td></tr>
<tr class="separator:a918dbca1f74786143db5ce22ba36dae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6465366d667eb4f37681119093eb9c67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#a6465366d667eb4f37681119093eb9c67">add_data_handlers</a> (const char *<a class="el" href="class_element.html#ae9d788e790a336314f3525cb4e635c1a">name</a>, int <a class="el" href="class_element.html#ac3924d1c0d1e5fa7e856b20df02309a7">flags</a>, int *data)</td></tr>
<tr class="separator:a6465366d667eb4f37681119093eb9c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61fc8b2548ceb3b3ccdba2a5c0fe78e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#a61fc8b2548ceb3b3ccdba2a5c0fe78e3">add_data_handlers</a> (const char *<a class="el" href="class_element.html#ae9d788e790a336314f3525cb4e635c1a">name</a>, int <a class="el" href="class_element.html#ac3924d1c0d1e5fa7e856b20df02309a7">flags</a>, unsigned *data)</td></tr>
<tr class="separator:a61fc8b2548ceb3b3ccdba2a5c0fe78e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa351db1c26ae9226ecae40514158ed2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#aa351db1c26ae9226ecae40514158ed2f">add_data_handlers</a> (const char *<a class="el" href="class_element.html#ae9d788e790a336314f3525cb4e635c1a">name</a>, int <a class="el" href="class_element.html#ac3924d1c0d1e5fa7e856b20df02309a7">flags</a>, <a class="el" href="classatomic__uint32__t.html">atomic_uint32_t</a> *data)</td></tr>
<tr class="separator:aa351db1c26ae9226ecae40514158ed2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e6275e9870024735b8c8a263211b382"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#a6e6275e9870024735b8c8a263211b382">add_data_handlers</a> (const char *<a class="el" href="class_element.html#ae9d788e790a336314f3525cb4e635c1a">name</a>, int <a class="el" href="class_element.html#ac3924d1c0d1e5fa7e856b20df02309a7">flags</a>, long *data)</td></tr>
<tr class="separator:a6e6275e9870024735b8c8a263211b382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a230f229edd9f19104679c95a04abc8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#a7a230f229edd9f19104679c95a04abc8">add_data_handlers</a> (const char *<a class="el" href="class_element.html#ae9d788e790a336314f3525cb4e635c1a">name</a>, int <a class="el" href="class_element.html#ac3924d1c0d1e5fa7e856b20df02309a7">flags</a>, unsigned long *data)</td></tr>
<tr class="separator:a7a230f229edd9f19104679c95a04abc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6de35fe05cfb0538205833043acc4c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#aa6de35fe05cfb0538205833043acc4c3">add_net_order_data_handlers</a> (const char *<a class="el" href="class_element.html#ae9d788e790a336314f3525cb4e635c1a">name</a>, int <a class="el" href="class_element.html#ac3924d1c0d1e5fa7e856b20df02309a7">flags</a>, uint16_t *data)</td></tr>
<tr class="memdesc:aa6de35fe05cfb0538205833043acc4c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register read and/or write handlers accessing <em>data</em> in network byte order.  <a href="#aa6de35fe05cfb0538205833043acc4c3">More...</a><br/></td></tr>
<tr class="separator:aa6de35fe05cfb0538205833043acc4c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8d4f1a3763729961e4ab84ed4a7dce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#ace8d4f1a3763729961e4ab84ed4a7dce">add_net_order_data_handlers</a> (const char *<a class="el" href="class_element.html#ae9d788e790a336314f3525cb4e635c1a">name</a>, int <a class="el" href="class_element.html#ac3924d1c0d1e5fa7e856b20df02309a7">flags</a>, uint32_t *data)</td></tr>
<tr class="separator:ace8d4f1a3763729961e4ab84ed4a7dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5af24565484eef392bd1a808ed3c9e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#ab5af24565484eef392bd1a808ed3c9e6">add_data_handlers</a> (const char *<a class="el" href="class_element.html#ae9d788e790a336314f3525cb4e635c1a">name</a>, int <a class="el" href="class_element.html#ac3924d1c0d1e5fa7e856b20df02309a7">flags</a>, double *data)</td></tr>
<tr class="separator:ab5af24565484eef392bd1a808ed3c9e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d06b77d29e5d199410c0ad7f8419a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#ad8d06b77d29e5d199410c0ad7f8419a8">add_data_handlers</a> (const char *<a class="el" href="class_element.html#ae9d788e790a336314f3525cb4e635c1a">name</a>, int <a class="el" href="class_element.html#ac3924d1c0d1e5fa7e856b20df02309a7">flags</a>, <a class="el" href="class_string.html">String</a> *data)</td></tr>
<tr class="memdesc:ad8d06b77d29e5d199410c0ad7f8419a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register read and/or write handlers accessing <em>data</em>.  <a href="#ad8d06b77d29e5d199410c0ad7f8419a8">More...</a><br/></td></tr>
<tr class="separator:ad8d06b77d29e5d199410c0ad7f8419a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21152aa5d1e8557ebb8168fb6cdd70c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#a21152aa5d1e8557ebb8168fb6cdd70c1">add_data_handlers</a> (const char *<a class="el" href="class_element.html#ae9d788e790a336314f3525cb4e635c1a">name</a>, int <a class="el" href="class_element.html#ac3924d1c0d1e5fa7e856b20df02309a7">flags</a>, <a class="el" href="class_i_p_address.html">IPAddress</a> *data)</td></tr>
<tr class="separator:a21152aa5d1e8557ebb8168fb6cdd70c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c3eca9a77a2443b7ef43dedb292bda9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#a7c3eca9a77a2443b7ef43dedb292bda9">add_data_handlers</a> (const char *<a class="el" href="class_element.html#ae9d788e790a336314f3525cb4e635c1a">name</a>, int <a class="el" href="class_element.html#ac3924d1c0d1e5fa7e856b20df02309a7">flags</a>, <a class="el" href="class_ether_address.html">EtherAddress</a> *data)</td></tr>
<tr class="separator:a7c3eca9a77a2443b7ef43dedb292bda9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f661ec13f3319da730eeb78db77c38e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#a1f661ec13f3319da730eeb78db77c38e">add_data_handlers</a> (const char *<a class="el" href="class_element.html#ae9d788e790a336314f3525cb4e635c1a">name</a>, int <a class="el" href="class_element.html#ac3924d1c0d1e5fa7e856b20df02309a7">flags</a>, <a class="el" href="class_timestamp.html">Timestamp</a> *data, bool is_interval=false)</td></tr>
<tr class="memdesc:a1f661ec13f3319da730eeb78db77c38e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register read and/or write handlers accessing <em>data</em>.  <a href="#a1f661ec13f3319da730eeb78db77c38e">More...</a><br/></td></tr>
<tr class="separator:a1f661ec13f3319da730eeb78db77c38e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a167cc0ddc82c96e127a039e31168546c"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#a167cc0ddc82c96e127a039e31168546c">llrpc</a> (unsigned command, void *arg)</td></tr>
<tr class="memdesc:a167cc0ddc82c96e127a039e31168546c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle a low-level remote procedure call.  <a href="#a167cc0ddc82c96e127a039e31168546c">More...</a><br/></td></tr>
<tr class="separator:a167cc0ddc82c96e127a039e31168546c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af13791d53b74844a08ffe4c1ba771b81"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#af13791d53b74844a08ffe4c1ba771b81">local_llrpc</a> (unsigned command, void *arg)</td></tr>
<tr class="memdesc:af13791d53b74844a08ffe4c1ba771b81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute an LLRPC from within the configuration.  <a href="#af13791d53b74844a08ffe4c1ba771b81">More...</a><br/></td></tr>
<tr class="separator:af13791d53b74844a08ffe4c1ba771b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a37b29a5c70f9e5b384c419bc8cb31e8a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#a37b29a5c70f9e5b384c419bc8cb31e8a">static_initialize</a> ()</td></tr>
<tr class="memdesc:a37b29a5c70f9e5b384c419bc8cb31e8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize static data for this element class.  <a href="#a37b29a5c70f9e5b384c419bc8cb31e8a">More...</a><br/></td></tr>
<tr class="separator:a37b29a5c70f9e5b384c419bc8cb31e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3ceb9d99079a10d4df6eb1f920a7e75"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#ac3ceb9d99079a10d4df6eb1f920a7e75">static_cleanup</a> ()</td></tr>
<tr class="memdesc:ac3ceb9d99079a10d4df6eb1f920a7e75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean up static data for this element class.  <a href="#ac3ceb9d99079a10d4df6eb1f920a7e75">More...</a><br/></td></tr>
<tr class="separator:ac3ceb9d99079a10d4df6eb1f920a7e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a8c339915279661504132604484e7b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_string.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#ad1a8c339915279661504132604484e7b">read_positional_handler</a> (<a class="el" href="class_element.html">Element</a> *, void *)</td></tr>
<tr class="memdesc:ad1a8c339915279661504132604484e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard read handler returning a positional argument.  <a href="#ad1a8c339915279661504132604484e7b">More...</a><br/></td></tr>
<tr class="separator:ad1a8c339915279661504132604484e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc959b669793b2925854ba2a5e6760d6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_string.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#abc959b669793b2925854ba2a5e6760d6">read_keyword_handler</a> (<a class="el" href="class_element.html">Element</a> *, void *)</td></tr>
<tr class="memdesc:abc959b669793b2925854ba2a5e6760d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard read handler returning a keyword argument.  <a href="#abc959b669793b2925854ba2a5e6760d6">More...</a><br/></td></tr>
<tr class="separator:abc959b669793b2925854ba2a5e6760d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b6ab2cdc14122476473eb3baf5791f7"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#a1b6ab2cdc14122476473eb3baf5791f7">reconfigure_positional_handler</a> (const <a class="el" href="class_string.html">String</a> &amp;, <a class="el" href="class_element.html">Element</a> *, void *, <a class="el" href="class_error_handler.html">ErrorHandler</a> *)</td></tr>
<tr class="memdesc:a1b6ab2cdc14122476473eb3baf5791f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard write handler for reconfiguring an element by changing one of its positional arguments.  <a href="#a1b6ab2cdc14122476473eb3baf5791f7">More...</a><br/></td></tr>
<tr class="separator:a1b6ab2cdc14122476473eb3baf5791f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a821ac1ae1b0879239be4895f8e211a54"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_element.html#a821ac1ae1b0879239be4895f8e211a54">reconfigure_keyword_handler</a> (const <a class="el" href="class_string.html">String</a> &amp;, <a class="el" href="class_element.html">Element</a> *, void *, <a class="el" href="class_error_handler.html">ErrorHandler</a> *)</td></tr>
<tr class="memdesc:a821ac1ae1b0879239be4895f8e211a54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard write handler for reconfiguring an element by changing one of its keyword arguments.  <a href="#a821ac1ae1b0879239be4895f8e211a54">More...</a><br/></td></tr>
<tr class="separator:a821ac1ae1b0879239be4895f8e211a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:adb3a34f52c4b7ace4a7e2aed5cce1806"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb3a34f52c4b7ace4a7e2aed5cce1806"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>nelements_allocated</b> = 0</td></tr>
<tr class="separator:adb3a34f52c4b7ace4a7e2aed5cce1806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a777c6de0fa9d03e6556267ce38543bac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a777c6de0fa9d03e6556267ce38543bac"></a>
static const char&#160;</td><td class="memItemRight" valign="bottom"><b>PORTS_0_0</b> [] = &quot;0&quot;</td></tr>
<tr class="separator:a777c6de0fa9d03e6556267ce38543bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad83c436a4767d1374834695e2c6edd68"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad83c436a4767d1374834695e2c6edd68"></a>
static const char&#160;</td><td class="memItemRight" valign="bottom"><b>PORTS_0_1</b> [] = &quot;0/1&quot;</td></tr>
<tr class="separator:ad83c436a4767d1374834695e2c6edd68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87166382358201e4bb34186cdee1f8d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a87166382358201e4bb34186cdee1f8d8"></a>
static const char&#160;</td><td class="memItemRight" valign="bottom"><b>PORTS_1_0</b> [] = &quot;1/0&quot;</td></tr>
<tr class="separator:a87166382358201e4bb34186cdee1f8d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae599fafe1bcc55b0aa98d8cbb63b0351"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae599fafe1bcc55b0aa98d8cbb63b0351"></a>
static const char&#160;</td><td class="memItemRight" valign="bottom"><b>PORTS_1_1</b> [] = &quot;1&quot;</td></tr>
<tr class="separator:ae599fafe1bcc55b0aa98d8cbb63b0351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaccb01a84924048fbf434727571d9877"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaccb01a84924048fbf434727571d9877"></a>
static const char&#160;</td><td class="memItemRight" valign="bottom"><b>PORTS_1_1X2</b> [] = &quot;1/1-2&quot;</td></tr>
<tr class="separator:aaccb01a84924048fbf434727571d9877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5627f44117a996496996e9093022243d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5627f44117a996496996e9093022243d"></a>
static const char&#160;</td><td class="memItemRight" valign="bottom"><b>AGNOSTIC</b> [] = &quot;a&quot;</td></tr>
<tr class="separator:a5627f44117a996496996e9093022243d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd9f2b08d056dcdb2f5752accc323f3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4dd9f2b08d056dcdb2f5752accc323f3"></a>
static const char&#160;</td><td class="memItemRight" valign="bottom"><b>PUSH</b> [] = &quot;h&quot;</td></tr>
<tr class="separator:a4dd9f2b08d056dcdb2f5752accc323f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ad975ca6a6eea4738f449bff79583f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41ad975ca6a6eea4738f449bff79583f"></a>
static const char&#160;</td><td class="memItemRight" valign="bottom"><b>PULL</b> [] = &quot;l&quot;</td></tr>
<tr class="separator:a41ad975ca6a6eea4738f449bff79583f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada4c013737eda99bd9b2fbcd54fd7ad8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ada4c013737eda99bd9b2fbcd54fd7ad8"></a>
static const char&#160;</td><td class="memItemRight" valign="bottom"><b>PUSH_TO_PULL</b> [] = &quot;h/l&quot;</td></tr>
<tr class="separator:ada4c013737eda99bd9b2fbcd54fd7ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a913131ef5863c5879c41b0b5e153e310"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a913131ef5863c5879c41b0b5e153e310"></a>
static const char&#160;</td><td class="memItemRight" valign="bottom"><b>PULL_TO_PUSH</b> [] = &quot;l/h&quot;</td></tr>
<tr class="separator:a913131ef5863c5879c41b0b5e153e310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d0acd19b428692a6384cdf11ccc986c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7d0acd19b428692a6384cdf11ccc986c"></a>
static const char&#160;</td><td class="memItemRight" valign="bottom"><b>PROCESSING_A_AH</b> [] = &quot;a/ah&quot;</td></tr>
<tr class="separator:a7d0acd19b428692a6384cdf11ccc986c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2966316d061247a3cbd7308c8b115747"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2966316d061247a3cbd7308c8b115747"></a>
static const char&#160;</td><td class="memItemRight" valign="bottom"><b>COMPLETE_FLOW</b> [] = &quot;x/x&quot;</td></tr>
<tr class="separator:a2966316d061247a3cbd7308c8b115747"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Base class for Click elements. </p>
<p>Click programmers spend most of their time writing elements, which are subclasses of class <a class="el" href="class_element.html" title="Base class for Click elements. ">Element</a>. <a class="el" href="class_element.html" title="Base class for Click elements. ">Element</a> provides functionality of its own, particularly the <a class="el" href="class_element.html#a526e36b67e098181d2b3232193427b27" title="Return one of the element&#39;s input ports. ">input()</a> and <a class="el" href="class_element.html#a3b3d622841bb29ee99da17ddba88a471" title="Return one of the element&#39;s output ports. ">output()</a> methods and associated <a class="el" href="class_element_1_1_port.html" title="An Element&#39;s ports. ">Element::Port</a> objects. More important, however, is the set of functions that derived classes override to define element behavior. Good Click programmers understand how the Click system uses these functions to manipulate and initialize elements. These functions fall into several categories:</p>
<dl>
<dt>Behavior specifications </dt>
<dd>These functions return static constants that describe element properties, such as class names, valid numbers of ports, and port processing types. Their values are automatically extracted from element source code for use by tools, so your source code should follow a specific syntax. Examples: <a class="el" href="class_element.html#ad8041b7068aea6830808a42afeddfcfd" title="Return the element&#39;s class name. ">class_name()</a>, <a class="el" href="class_element.html#ae5b51c221451df6a3045f7e523c2e892" title="Return the element&#39;s port count specifier. ">port_count()</a>, <a class="el" href="class_element.html#aa1fc03e194bd7b55481d55b9b41b751e" title="Return the element&#39;s processing specifier. ">processing()</a>, <a class="el" href="class_element.html#acb359ed32700d440149ba50cea37ae8b" title="Return the element&#39;s internal packet flow specifier (its flow code). ">flow_code()</a>, <a class="el" href="class_element.html#ac3924d1c0d1e5fa7e856b20df02309a7" title="Return the element&#39;s flags. ">flags()</a>. </dd>
<dt>Configuration, initialization, and cleanup </dt>
<dd>Configuration and initialization functions are called to set up an element as a router is initialized (or when the element itself is reconfigured). Most of the functions are passed an <a class="el" href="class_error_handler.html" title="Error reporting class. ">ErrorHandler</a> argument, to which they should report any errors. By returning negative values, they can prevent the router from initializing. Other functions clean up elements when a router is removed and reconfigure an element as the router runs. Examples: <a class="el" href="class_element.html#ae19904c6060f3d4411e32cba0dd2e3c1" title="Attempt to cast the element to a named type. ">cast()</a>, <a class="el" href="class_element.html#ab2bb58f562728df47d007fd12a9e92f4" title="Parse the element&#39;s configuration arguments. ">configure()</a>, <a class="el" href="class_element.html#a1e6b1d114dfacf402fe5066ec0f3cf92" title="Return the element&#39;s configure phase, which determines the order in which elements are configured and...">configure_phase()</a>, <a class="el" href="class_element.html#a65a2efbc7c6af095d16cf31015e9216f" title="Install the element&#39;s handlers. ">add_handlers()</a>, <a class="el" href="class_element.html#abf2bbb7d3ae5a1372a6af9d7bb8269fe" title="Initialize the element. ">initialize()</a>, <a class="el" href="class_element.html#abbf80c057f2d850ac85de15e22d58c52" title="Initialize the element for hotswap, where the element should take old_element&#39;s state, if possible. ">take_state()</a>, <a class="el" href="class_element.html#aa58cba2310e9207a8afa1c5f4ecfc878" title="Clean up the element&#39;s state. ">cleanup()</a>, <a class="el" href="class_element.html#aea3e2211f7024e49d4120ed7734f5fa9" title="Return whether an element supports live reconfiguration. ">can_live_reconfigure()</a>, <a class="el" href="class_element.html#a56db8a2641022efc353efed36fdd73f1" title="Reconfigure the element while the router is running. ">live_reconfigure()</a>. </dd>
<dt><a class="el" href="class_packet.html" title="A network packet. ">Packet</a> and event processing </dt>
<dd>These functions are called as the router runs to process packets and other events. Examples: <a class="el" href="class_element.html#af63395e97dd323b90d427e2eaae087eb" title="Push packet p onto push input port. ">push()</a>, <a class="el" href="class_element.html#ace8c7b8b37f177b9a9cc024d8b64f3a3" title="Pull a packet from pull output port. ">pull()</a>, <a class="el" href="class_element.html#a8dbe693607180d74bdbcd01110b77621" title="Process a packet for a simple packet filter. ">simple_action()</a>, <a class="el" href="class_element.html#ab40229beca000d06db59fd4720e319db" title="Run the element&#39;s task. ">run_task()</a>, <a class="el" href="class_element.html#adee431d2b975bc658e96e5ad98d30550" title="Run the element&#39;s timer. ">run_timer()</a>, <a class="el" href="class_element.html#aa98e97859a6506f467fa6cb6a276c1f3" title="Handle a file descriptor event. ">selected()</a>. </dd>
</dl>
<h3>Examples</h3>
<p>Here is the simplest possible element definition.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyNothingElement : <span class="keyword">public</span> <a class="code" href="class_element.html">Element</a> { <span class="keyword">public</span>:</div>
<div class="line">    MyNothingElement() { }</div>
<div class="line">    ~MyNothingElement() { }</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="class_element.html#ad8041b7068aea6830808a42afeddfcfd">class_name</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;MyNothingElement&quot;</span>; }</div>
<div class="line">};</div>
</div><!-- fragment --><p>This element has no ports and accepts no configuration arguments; it does nothing. The required <a class="el" href="class_element.html#ad8041b7068aea6830808a42afeddfcfd" title="Return the element&#39;s class name. ">class_name()</a> function informs Click's infrastructure of the element's class name.</p>
<p>Although this element is code-complete, Click's build process requires a bit more boilerplate, like so:</p>
<div class="fragment"><div class="line"><span class="comment">// ================== elements/local/mynothingelement.hh ==================</span></div>
<div class="line"><span class="preprocessor">#ifndef CLICK_MYNOTHINGELEMENT_HH</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#define CLICK_MYNOTHINGELEMENT_HH</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#include &lt;<a class="code" href="element_8hh.html">click/element.hh</a>&gt;</span></div>
<div class="line">CLICK_DECLS</div>
<div class="line"><span class="keyword">class </span>MyNothingElement : <span class="keyword">public</span> <a class="code" href="class_element.html">Element</a> { <span class="keyword">public</span>:</div>
<div class="line">    MyNothingElement() { }</div>
<div class="line">    ~MyNothingElement() { }</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="class_element.html#ad8041b7068aea6830808a42afeddfcfd">class_name</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;MyNothingElement&quot;</span>; }</div>
<div class="line">};</div>
<div class="line">CLICK_ENDDECLS</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="comment">// ================== elements/local/mynothingelement.cc ==================</span></div>
<div class="line"><span class="preprocessor">#include &lt;click/config.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;mynothingelement.hh&quot;</span></div>
<div class="line">CLICK_DECLS</div>
<div class="line"><span class="comment">// Non-inline element code would go here.</span></div>
<div class="line">CLICK_ENDDECLS</div>
<div class="line">EXPORT_ELEMENT(MyNothingElement)</div>
</div><!-- fragment --><p>Some things to notice:</p>
<ul>
<li>The element class must be defined in a header file and a source file.</li>
<li>The header file is protected from multiple inclusion. A common error is to copy and paste another element's header file, but forget to change the header protection symbol (here, CLICK_MYNOTHINGELEMENT_HH).</li>
<li>All Click declarations are enclosed within a macro pair, <code>CLICK_DECLS</code> and <code>CLICK_ENDDECLS</code>. These are required for the NS and FreeBSD kernel drivers. Note that <code>#include</code> statements go <em>outside</em> the <code>CLICK_DECLS/CLICK_ENDDECLS</code> pair.</li>
<li>The element's C++ class is defined in the header file.</li>
<li>The first thing the source file does is <code>#include &lt;<a class="el" href="config_8h_source.html">click/config.h</a>&gt;</code>. <b>This is mandatory.</b></li>
<li>The source file must contain a line like <code>EXPORT_ELEMENT(NameOfC++ClassForElement)</code>. Click's compilation process will ignore your element unless there's a line like this.</li>
</ul>
<p>This slightly more complex example illustrates some more of Click's element infrastructure.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyNullElement : <span class="keyword">public</span> <a class="code" href="class_element.html">Element</a> { <span class="keyword">public</span>:</div>
<div class="line">    MyNullElement() { }</div>
<div class="line">    ~MyNullElement() { }</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="class_element.html#ad8041b7068aea6830808a42afeddfcfd">class_name</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;MyNullElement&quot;</span>; }</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="class_element.html#ae5b51c221451df6a3045f7e523c2e892">port_count</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> PORTS_1_1; }</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="class_element.html#aa1fc03e194bd7b55481d55b9b41b751e">processing</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> PUSH; }</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="class_element.html#af63395e97dd323b90d427e2eaae087eb">push</a>(<span class="keywordtype">int</span> <a class="code" href="class_element.html#a397a2f89d50f1656b4d7c0334fa2747c">port</a>, <a class="code" href="class_packet.html">Packet</a> *p) {</div>
<div class="line">        <a class="code" href="class_element.html#a3b3d622841bb29ee99da17ddba88a471">output</a>(0).<a class="code" href="class_element_1_1_port.html#a041e961db96721656ac414259c5af0ae">push</a>(p);</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p>This element processes packets in push mode, much like the standard <em>PushNull</em> element.</p>
<ul>
<li>
The <a class="el" href="class_element.html#ae5b51c221451df6a3045f7e523c2e892" title="Return the element&#39;s port count specifier. ">port_count()</a> method tells Click that this element has one input and one output. See <a class="el" href="class_element.html#ae5b51c221451df6a3045f7e523c2e892" title="Return the element&#39;s port count specifier. ">port_count()</a> for more. </li>
<li>
The <a class="el" href="class_element.html#aa1fc03e194bd7b55481d55b9b41b751e" title="Return the element&#39;s processing specifier. ">processing()</a> method tells Click that this element's ports are in push mode. See <a class="el" href="class_element.html#aa1fc03e194bd7b55481d55b9b41b751e" title="Return the element&#39;s processing specifier. ">processing()</a> for more. </li>
<li>
The element doesn't define a <a class="el" href="class_element.html#ab2bb58f562728df47d007fd12a9e92f4" title="Parse the element&#39;s configuration arguments. ">configure()</a> or <a class="el" href="class_element.html#abf2bbb7d3ae5a1372a6af9d7bb8269fe" title="Initialize the element. ">initialize()</a> method, so the defaults are used: the element takes no configuration arguments, and always initializes successfully. </li>
<li>
The element has just one function called after router initialization, namely <a class="el" href="class_element.html#af63395e97dd323b90d427e2eaae087eb" title="Push packet p onto push input port. ">push()</a>. This function is called when another element pushes a packet to this element. The implementation here simply pushes the packet to the element's first output port. </li>
<li>
<p class="startli"><b>Invariants:</b> Click's initialization process checks for many kinds of errors, allowing the <a class="el" href="class_element.html#af63395e97dd323b90d427e2eaae087eb" title="Push packet p onto push input port. ">push()</a> method to assume several invariants. In particular, <a class="el" href="class_element.html#ae5b51c221451df6a3045f7e523c2e892" title="Return the element&#39;s port count specifier. ">port_count()</a> and <a class="el" href="class_element.html#aa1fc03e194bd7b55481d55b9b41b751e" title="Return the element&#39;s processing specifier. ">processing()</a> specify that this element has one push input and one push output. Click therefore ensures that the element's first input is used in a connection at least once; that its first output is used in a connection <em>exactly</em> once; that its other inputs and outputs are not used at all; and that all connections involving the element's ports are push.</p>
<p>As a result, the <a class="el" href="class_element.html#af63395e97dd323b90d427e2eaae087eb" title="Push packet p onto push input port. ">push()</a> method can assume that <code>port == 0</code>, that <code>output(0)</code> exists, and that <code>output(0).push(p)</code> is valid.</p>
<p>Elements must not push null packet pointers, either, so the <a class="el" href="class_element.html#af63395e97dd323b90d427e2eaae087eb" title="Push packet p onto push input port. ">push()</a> method can assume that <code>p != 0</code>.</p>
<p class="endli">There is no harm in verifying these invariants with assertions, since bogus element code can violate them (by passing a bad value for <code>port</code> or <code>p</code>, for example), but such errors are rare in practice. Our elements mostly assume that the invariants hold. </p>
</li>
</ul>
<h3><a class="el" href="class_packet.html" title="A network packet. ">Packet</a> Accounting</h3>
<p><a class="el" href="class_element.html" title="Base class for Click elements. ">Element</a> run-time methods, such as <a class="el" href="class_element.html#af63395e97dd323b90d427e2eaae087eb" title="Push packet p onto push input port. ">push()</a>, <a class="el" href="class_element.html#ace8c7b8b37f177b9a9cc024d8b64f3a3" title="Pull a packet from pull output port. ">pull()</a>, <a class="el" href="class_element.html#ab40229beca000d06db59fd4720e319db" title="Run the element&#39;s task. ">run_task()</a>, and <a class="el" href="class_element.html#adee431d2b975bc658e96e5ad98d30550" title="Run the element&#39;s timer. ">run_timer()</a>, must always obey the following rules:</p>
<ul>
<li>Each <a class="el" href="class_packet.html" title="A network packet. ">Packet</a> pointer is used by at most one element at a time.</li>
<li>An element that obtains a <a class="el" href="class_packet.html" title="A network packet. ">Packet</a> pointer must eventually free it or pass it to another element. This avoids memory leaks.</li>
</ul>
<p>Beginning Click programmers often violate these rules. Here are some examples to make them concrete.</p>
<p>This incorrect version of Click's <em>Tee</em> element attempts to duplicate a packet and send the duplicates to two different outputs.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> BadTee::push(<span class="keywordtype">int</span> <a class="code" href="class_element.html#a397a2f89d50f1656b4d7c0334fa2747c">port</a>, <a class="code" href="class_packet.html">Packet</a> *p) {</div>
<div class="line">    <a class="code" href="class_element.html#a3b3d622841bb29ee99da17ddba88a471">output</a>(0).<a class="code" href="class_element_1_1_port.html#a041e961db96721656ac414259c5af0ae">push</a>(p);</div>
<div class="line">    <a class="code" href="class_element.html#a3b3d622841bb29ee99da17ddba88a471">output</a>(1).<a class="code" href="class_element_1_1_port.html#a041e961db96721656ac414259c5af0ae">push</a>(p);</div>
<div class="line">}</div>
</div><!-- fragment --><p>A single packet pointer <code>p</code> has been pushed to two different outputs. This is always illegal; the rest of the configuration may have modified or even freed the packet before returning control to <em>BadTee</em>, so <code>output(1).push(p)</code> would probably touch freed memory! This situation requires the <a class="el" href="class_packet.html#aa274049bd162e38785c514fa512c44e8" title="Create a clone of this packet. ">Packet::clone()</a> method, which makes a copy of a packet:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> BetterTee::push(<span class="keywordtype">int</span> port, <a class="code" href="class_packet.html">Packet</a> *p) {</div>
<div class="line">    <a class="code" href="class_element.html#a3b3d622841bb29ee99da17ddba88a471">output</a>(0).<a class="code" href="class_element_1_1_port.html#a041e961db96721656ac414259c5af0ae">push</a>(p-&gt;<a class="code" href="class_packet.html#aa274049bd162e38785c514fa512c44e8">clone</a>());</div>
<div class="line">    <a class="code" href="class_element.html#a3b3d622841bb29ee99da17ddba88a471">output</a>(1).<a class="code" href="class_element_1_1_port.html#a041e961db96721656ac414259c5af0ae">push</a>(p);</div>
<div class="line">}</div>
</div><!-- fragment --><p>However, <em>BetterTee</em> would fail if the router ran out of memory for packet clones. <code>p-&gt;clone()</code> would return null, and passing a null pointer to another element's <a class="el" href="class_element.html#af63395e97dd323b90d427e2eaae087eb" title="Push packet p onto push input port. ">push()</a> method isn't allowed. Here's how to fix this:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> BestTee::push(<span class="keywordtype">int</span> port, <a class="code" href="class_packet.html">Packet</a> *p) {</div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code" href="class_packet.html">Packet</a> *clone = p-&gt;<a class="code" href="class_packet.html#aa274049bd162e38785c514fa512c44e8">clone</a>())</div>
<div class="line">        <a class="code" href="class_element.html#a3b3d622841bb29ee99da17ddba88a471">output</a>(0).<a class="code" href="class_element_1_1_port.html#a041e961db96721656ac414259c5af0ae">push</a>(clone);</div>
<div class="line">    <a class="code" href="class_element.html#a3b3d622841bb29ee99da17ddba88a471">output</a>(1).<a class="code" href="class_element_1_1_port.html#a041e961db96721656ac414259c5af0ae">push</a>(p);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Here's an example of a <a class="el" href="class_element.html#af63395e97dd323b90d427e2eaae087eb" title="Push packet p onto push input port. ">push()</a> method with an obvious leak:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> LeakyCounter::push(<span class="keywordtype">int</span> port, <a class="code" href="class_packet.html">Packet</a> *p) {</div>
<div class="line">    _counter++;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The method doesn't do anything with <code>p</code>, so its memory will never be reclaimed. Instead, it should either free the packet or pass it on to another element:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> BetterCounter1::push(<span class="keywordtype">int</span> port, <a class="code" href="class_packet.html">Packet</a> *p) {</div>
<div class="line">    _counter++;</div>
<div class="line">    p-&gt;<a class="code" href="class_packet.html#a4c95c6ebd45e8c7d1b85b22b27b29118">kill</a>();            <span class="comment">// free packet</span></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> BetterCounter2::push(<span class="keywordtype">int</span> port, <a class="code" href="class_packet.html">Packet</a> *p) {</div>
<div class="line">    _counter++;</div>
<div class="line">    <a class="code" href="class_element.html#a3b3d622841bb29ee99da17ddba88a471">output</a>(0).<a class="code" href="class_element_1_1_port.html#a041e961db96721656ac414259c5af0ae">push</a>(p);    <span class="comment">// push packet on</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Leaks involving error conditions are more common in practice. For instance, this <a class="el" href="class_element.html#af63395e97dd323b90d427e2eaae087eb" title="Push packet p onto push input port. ">push()</a> method counts IP packets. The programmer has defensively checked whether or not the input packet's network header pointer is set.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> LeakyIPCounter::push(<span class="keywordtype">int</span> port, <a class="code" href="class_packet.html">Packet</a> *p) {</div>
<div class="line">    <span class="keywordflow">if</span> (!p-&gt;<a class="code" href="class_packet.html#a2d5062b798be9675617c84c0378a5922">has_network_header</a>())</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    _counter++;</div>
<div class="line">    <a class="code" href="class_element.html#a3b3d622841bb29ee99da17ddba88a471">output</a>(0).<a class="code" href="class_element_1_1_port.html#a041e961db96721656ac414259c5af0ae">push</a>(p);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Close, but no cigar: if the input packet has no network header pointer, the packet will leak. Here are some better versions.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> BetterIPCounter1::push(<span class="keywordtype">int</span> port, <a class="code" href="class_packet.html">Packet</a> *p) {</div>
<div class="line">    <span class="comment">// In this version, non-IP packets are dropped.  This is closest to LeakyIPCounter&#39;s intended functionality.</span></div>
<div class="line">    <span class="keywordflow">if</span> (!p-&gt;<a class="code" href="class_packet.html#a2d5062b798be9675617c84c0378a5922">has_network_header</a>()) {</div>
<div class="line">        p-&gt;<a class="code" href="class_packet.html#a4c95c6ebd45e8c7d1b85b22b27b29118">kill</a>();</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line">    _counter++;</div>
<div class="line">    <a class="code" href="class_element.html#a3b3d622841bb29ee99da17ddba88a471">output</a>(0).<a class="code" href="class_element_1_1_port.html#a041e961db96721656ac414259c5af0ae">push</a>(p);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> BetterIPCounter2::push(<span class="keywordtype">int</span> port, <a class="code" href="class_packet.html">Packet</a> *p) {</div>
<div class="line">    <span class="comment">// This programmer thinks non-IP packets are serious errors and should cause a crash.</span></div>
<div class="line">    assert(p-&gt;<a class="code" href="class_packet.html#a2d5062b798be9675617c84c0378a5922">has_network_header</a>());</div>
<div class="line">    _counter++;</div>
<div class="line">    <a class="code" href="class_element.html#a3b3d622841bb29ee99da17ddba88a471">output</a>(0).<a class="code" href="class_element_1_1_port.html#a041e961db96721656ac414259c5af0ae">push</a>(p);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> BetterIPCounter3::push(<span class="keywordtype">int</span> port, <a class="code" href="class_packet.html">Packet</a> *p) {</div>
<div class="line">    <span class="comment">// This programmer passes non-IP packets through without counting them.</span></div>
<div class="line">    <span class="keywordflow">if</span> (p-&gt;<a class="code" href="class_packet.html#a2d5062b798be9675617c84c0378a5922">has_network_header</a>())</div>
<div class="line">        _counter++;</div>
<div class="line">    <a class="code" href="class_element.html#a3b3d622841bb29ee99da17ddba88a471">output</a>(0).<a class="code" href="class_element_1_1_port.html#a041e961db96721656ac414259c5af0ae">push</a>(p);</div>
<div class="line">}</div>
</div><!-- fragment --><h3>Initialization Phases</h3>
<p>The Click infrastructure calls element initialization functions in a specific order during router initialization. Errors at any stage prevent later stages from running.</p>
<ol type="1">
<li>Collects element properties, specifically <a class="el" href="class_element.html#a1e6b1d114dfacf402fe5066ec0f3cf92" title="Return the element&#39;s configure phase, which determines the order in which elements are configured and...">configure_phase()</a>, <a class="el" href="class_element.html#ae5b51c221451df6a3045f7e523c2e892" title="Return the element&#39;s port count specifier. ">port_count()</a>, <a class="el" href="class_element.html#acb359ed32700d440149ba50cea37ae8b" title="Return the element&#39;s internal packet flow specifier (its flow code). ">flow_code()</a>, <a class="el" href="class_element.html#aa1fc03e194bd7b55481d55b9b41b751e" title="Return the element&#39;s processing specifier. ">processing()</a>, and <a class="el" href="class_element.html#aea3e2211f7024e49d4120ed7734f5fa9" title="Return whether an element supports live reconfiguration. ">can_live_reconfigure()</a>.</li>
<li>Calculates how many of each element's input and output ports are used in the configuration. There is an error if <a class="el" href="class_element.html#ae5b51c221451df6a3045f7e523c2e892" title="Return the element&#39;s port count specifier. ">port_count()</a> doesn't allow the result.</li>
<li>Calculates each port's push or pull status. This depends on <a class="el" href="class_element.html#aa1fc03e194bd7b55481d55b9b41b751e" title="Return the element&#39;s processing specifier. ">processing()</a> values, and for agnostic ports, a constraint satisfaction algorithm that uses <a class="el" href="class_element.html#acb359ed32700d440149ba50cea37ae8b" title="Return the element&#39;s internal packet flow specifier (its flow code). ">flow_code()</a>.</li>
<li>Checks that every connection is between two push ports or two pull ports; that there are no agnostic port conflicts (each port is used as push or pull, never both); that no port goes unused; and that push output ports and pull input ports are connected exactly once. Violations cause an error.</li>
<li>Sorts the elements by <a class="el" href="class_element.html#a1e6b1d114dfacf402fe5066ec0f3cf92" title="Return the element&#39;s configure phase, which determines the order in which elements are configured and...">configure_phase()</a> to construct a configuration order.</li>
<li>Calls each element's <a class="el" href="class_element.html#ab2bb58f562728df47d007fd12a9e92f4" title="Parse the element&#39;s configuration arguments. ">configure()</a> method in order, passing its configuration arguments and an <a class="el" href="class_error_handler.html" title="Error reporting class. ">ErrorHandler</a>. All <a class="el" href="class_element.html#ab2bb58f562728df47d007fd12a9e92f4" title="Parse the element&#39;s configuration arguments. ">configure()</a> functions are called, even if a prior <a class="el" href="class_element.html#ab2bb58f562728df47d007fd12a9e92f4" title="Parse the element&#39;s configuration arguments. ">configure()</a> function returns an error.</li>
<li>Calls every element's <a class="el" href="class_element.html#a65a2efbc7c6af095d16cf31015e9216f" title="Install the element&#39;s handlers. ">add_handlers()</a> method.</li>
<li>Calls every element's <a class="el" href="class_element.html#abf2bbb7d3ae5a1372a6af9d7bb8269fe" title="Initialize the element. ">initialize()</a> method in configuration order. Initialization is aborted as soon as any method returns an error (i.e., some <a class="el" href="class_element.html#abf2bbb7d3ae5a1372a6af9d7bb8269fe" title="Initialize the element. ">initialize()</a> methods might not be called).</li>
<li>At this point, the router will definitely be installed. If the router was installed with a hotswap option, then Click searches the old and new router for potentially compatible pairs using <a class="el" href="class_element.html#afde7f3dce9335145efd79c0d77527768" title="Return a compatible element in the hotswap router. ">hotswap_element()</a>, and calls <a class="el" href="class_element.html#abbf80c057f2d850ac85de15e22d58c52" title="Initialize the element for hotswap, where the element should take old_element&#39;s state, if possible. ">take_state()</a> for each pair. Any errors are ignored.</li>
<li>Installs the router.</li>
</ol>
<p><a class="el" href="class_router.html" title="A router configuration. ">Router</a> cleanup takes place as follows. Click:</p>
<ol type="1">
<li>Removes all element handlers.</li>
<li>Calls each element's <a class="el" href="class_element.html#aa58cba2310e9207a8afa1c5f4ecfc878" title="Clean up the element&#39;s state. ">cleanup()</a> function in reverse configuration order. The argument to <a class="el" href="class_element.html#aa58cba2310e9207a8afa1c5f4ecfc878" title="Clean up the element&#39;s state. ">cleanup()</a> indicates where the initialization process completed for that element. See <a class="el" href="class_element.html#aa58cba2310e9207a8afa1c5f4ecfc878" title="Clean up the element&#39;s state. ">cleanup()</a> for the specific constant names.</li>
<li>Deletes each element. This step might be delayed relative to <a class="el" href="class_element.html#aa58cba2310e9207a8afa1c5f4ecfc878" title="Clean up the element&#39;s state. ">cleanup()</a> to allow the programmer to examine an erroneous router's state. </li>
</ol>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ab0d0e20be9a36ae676202db753faeec9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Element::Element </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an <a class="el" href="class_element.html" title="Base class for Click elements. ">Element</a>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="af63395e97dd323b90d427e2eaae087eb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Element::push </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push packet <em>p</em> onto push input <em>port</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>the input port number on which the packet arrives </td></tr>
    <tr><td class="paramname">p</td><td>the packet</td></tr>
  </table>
  </dd>
</dl>
<p>An upstream element transferred packet <em>p</em> to this element over a push connection. This element should process the packet as necessary and return. The packet arrived on input port <em>port</em>. <a class="el" href="class_element.html#af63395e97dd323b90d427e2eaae087eb" title="Push packet p onto push input port. ">push()</a> must account for the packet either by pushing it further downstream, by freeing it, or by storing it temporarily.</p>
<p>The default implementation calls <a class="el" href="class_element.html#a8dbe693607180d74bdbcd01110b77621" title="Process a packet for a simple packet filter. ">simple_action()</a>. </p>

</div>
</div>
<a class="anchor" id="ace8c7b8b37f177b9a9cc024d8b64f3a3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_packet.html">Packet</a> * Element::pull </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pull a packet from pull output <em>port</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>the output port number receiving the pull request. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a packet</dd></dl>
<p>A downstream element initiated a packet transfer from this element over a pull connection. This element should return a packet pointer, or null if no packet is available. The pull request arrived on output port <em>port</em>.</p>
<p>Often, <a class="el" href="class_element.html#ace8c7b8b37f177b9a9cc024d8b64f3a3" title="Pull a packet from pull output port. ">pull()</a> methods will request packets from upstream using input(i).<a class="el" href="class_element.html#ace8c7b8b37f177b9a9cc024d8b64f3a3" title="Pull a packet from pull output port. ">pull()</a>. The default implementation calls <a class="el" href="class_element.html#a8dbe693607180d74bdbcd01110b77621" title="Process a packet for a simple packet filter. ">simple_action()</a>. </p>

</div>
</div>
<a class="anchor" id="a8dbe693607180d74bdbcd01110b77621"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_packet.html">Packet</a> * Element::simple_action </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Process a packet for a simple packet filter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the input packet </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output packet, or null</dd></dl>
<p>Many elements act as simple packet filters: they receive a packet from upstream using input 0, process that packet, and forward it downstream using output 0. The <a class="el" href="class_element.html#a8dbe693607180d74bdbcd01110b77621" title="Process a packet for a simple packet filter. ">simple_action()</a> method automates this process. The <em>p</em> argument is the input packet. <a class="el" href="class_element.html#a8dbe693607180d74bdbcd01110b77621" title="Process a packet for a simple packet filter. ">simple_action()</a> should process the packet and return a packet pointer &ndash; either the same packet, a different packet, or null. If the return value isn't null, Click will forward that packet downstream.</p>
<p><a class="el" href="class_element.html#a8dbe693607180d74bdbcd01110b77621" title="Process a packet for a simple packet filter. ">simple_action()</a> must account for <em>p</em>, either by returning it, by freeing it, or by emitting it on some alternate push output port. (An optional second push output port 1 is often used to emit erroneous packets.)</p>
<p><a class="el" href="class_element.html#a8dbe693607180d74bdbcd01110b77621" title="Process a packet for a simple packet filter. ">simple_action()</a> works equally well for push or pull port pairs. The default <a class="el" href="class_element.html#af63395e97dd323b90d427e2eaae087eb" title="Push packet p onto push input port. ">push()</a> method calls <a class="el" href="class_element.html#a8dbe693607180d74bdbcd01110b77621" title="Process a packet for a simple packet filter. ">simple_action()</a> this way:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> ((p = <a class="code" href="class_element.html#a8dbe693607180d74bdbcd01110b77621">simple_action</a>(p)))</div>
<div class="line">    <a class="code" href="class_element.html#a3b3d622841bb29ee99da17ddba88a471">output</a>(0).<a class="code" href="class_element_1_1_port.html#a041e961db96721656ac414259c5af0ae">push</a>(p);</div>
</div><!-- fragment --><p>The default <a class="el" href="class_element.html#ace8c7b8b37f177b9a9cc024d8b64f3a3" title="Pull a packet from pull output port. ">pull()</a> method calls it this way instead:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code" href="class_packet.html">Packet</a> *p = <a class="code" href="class_element.html#a526e36b67e098181d2b3232193427b27">input</a>(0).<a class="code" href="class_element.html#ace8c7b8b37f177b9a9cc024d8b64f3a3">pull</a>())</div>
<div class="line">    <span class="keywordflow">if</span> ((p = <a class="code" href="class_element.html#a8dbe693607180d74bdbcd01110b77621">simple_action</a>(p)))</div>
<div class="line">        <span class="keywordflow">return</span> p;</div>
<div class="line"><span class="keywordflow">return</span> 0;</div>
</div><!-- fragment --><p>An element that implements its processing with <a class="el" href="class_element.html#a8dbe693607180d74bdbcd01110b77621" title="Process a packet for a simple packet filter. ">simple_action()</a> should have a <a class="el" href="class_element.html#aa1fc03e194bd7b55481d55b9b41b751e" title="Return the element&#39;s processing specifier. ">processing()</a> code like AGNOSTIC or "a/ah", and a <a class="el" href="class_element.html#acb359ed32700d440149ba50cea37ae8b" title="Return the element&#39;s internal packet flow specifier (its flow code). ">flow_code()</a> like COMPLETE_FLOW or "x/x" indicating that packets can flow between the first input and the first output.</p>
<p>Most elements that use <a class="el" href="class_element.html#a8dbe693607180d74bdbcd01110b77621" title="Process a packet for a simple packet filter. ">simple_action()</a> have exactly one input and one output. However, <a class="el" href="class_element.html#a8dbe693607180d74bdbcd01110b77621" title="Process a packet for a simple packet filter. ">simple_action()</a> may be used for any number of inputs and outputs; a packet arriving on input port P will be emitted or output port P.</p>
<p>For technical branch prediction-related reasons, elements that use <a class="el" href="class_element.html#a8dbe693607180d74bdbcd01110b77621" title="Process a packet for a simple packet filter. ">simple_action()</a> can perform quite a bit slower than elements that use <a class="el" href="class_element.html#af63395e97dd323b90d427e2eaae087eb" title="Push packet p onto push input port. ">push()</a> and <a class="el" href="class_element.html#ace8c7b8b37f177b9a9cc024d8b64f3a3" title="Pull a packet from pull output port. ">pull()</a> directly. The devirtualizer (click-devirtualize) can mitigate this effect. </p>

</div>
</div>
<a class="anchor" id="ab40229beca000d06db59fd4720e319db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Element::run_task </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_task.html">Task</a> *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Run the element's task. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the task accomplished some meaningful work, false otherwise</dd></dl>
<p>The <a class="el" href="class_task.html" title="Represents a frequently-scheduled computational task. ">Task(Element *)</a> constructor creates a <a class="el" href="class_task.html" title="Represents a frequently-scheduled computational task. ">Task</a> object that calls this method when it fires. Most elements that have tasks use this method.</p>
<dl class="section note"><dt>Note</dt><dd>The default implementation causes an assertion failure. </dd></dl>

</div>
</div>
<a class="anchor" id="adee431d2b975bc658e96e5ad98d30550"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Element::run_timer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_timer.html">Timer</a> *&#160;</td>
          <td class="paramname"><em>timer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Run the element's timer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timer</td><td>the timer object that fired</td></tr>
  </table>
  </dd>
</dl>
<p>The <a class="el" href="class_timer.html" title="Triggers execution at a given time. ">Timer(Element *)</a> constructor creates a <a class="el" href="class_timer.html" title="Triggers execution at a given time. ">Timer</a> object that calls this method when it fires. Most elements that have timers use this method.</p>
<dl class="section note"><dt>Note</dt><dd>The default implementation causes an assertion failure. </dd></dl>

</div>
</div>
<a class="anchor" id="aa98e97859a6506f467fa6cb6a276c1f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Element::selected </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handle a file descriptor event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>the file descriptor </td></tr>
    <tr><td class="paramname">mask</td><td>relevant events: bitwise-or of one or more of SELECT_READ, SELECT_WRITE</td></tr>
  </table>
  </dd>
</dl>
<p>Click's call to select() indicates that the file descriptor <em>fd</em> is readable, writable, or both. The overriding method should read or write the file descriptor as appropriate. The default implementation causes an assertion failure.</p>
<p>The element must have previously registered interest in <em>fd</em> with <a class="el" href="class_element.html#a7ed6015f3a12301042b6abcdcc6d082d" title="Register interest in mask events on file descriptor fd. ">add_select()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Only available at user level.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_element.html#a7ed6015f3a12301042b6abcdcc6d082d" title="Register interest in mask events on file descriptor fd. ">add_select</a>, <a class="el" href="class_element.html#a7c789f9051b016234f5f6c02dc8243fa" title="Remove interest in mask events on file descriptor fd. ">remove_select</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9e80acc32be82a8a77e443d83df5665f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Element::selected </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handle a file descriptor event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>the file descriptor</td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000021">Deprecated:</a></b></dt><dd>Elements should define selected(<em>fd</em>, mask) in preference to selected(<em>fd</em>). The default implementation of selected(<em>fd</em>, mask) calls selected(<em>fd</em>) for backwards compatibility.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only available at user level.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_element.html#a7ed6015f3a12301042b6abcdcc6d082d" title="Register interest in mask events on file descriptor fd. ">add_select</a>, <a class="el" href="class_element.html#a7c789f9051b016234f5f6c02dc8243fa" title="Remove interest in mask events on file descriptor fd. ">remove_select</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a614ea4f79ad3f6cfd54f25a7df58d20e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Element::checked_output_push </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push packet <em>p</em> to output <em>port</em>, or kill it if <em>port</em> is out of range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>output port number </td></tr>
    <tr><td class="paramname">p</td><td>packet to push</td></tr>
  </table>
  </dd>
</dl>
<p>If <em>port</em> is in range (&gt;= 0 and &lt; <a class="el" href="class_element.html#a3b909f7829ff14f5b1dd4165580f69f8" title="Return the number of output ports. ">noutputs()</a>), then push packet <em>p</em> forward using output(<em>port</em>).push(<em>p</em>). Otherwise, kill <em>p</em> with <em>p</em> -&gt;kill().</p>
<dl class="section note"><dt>Note</dt><dd>It is invalid to call <a class="el" href="class_element.html#a614ea4f79ad3f6cfd54f25a7df58d20e" title="Push packet p to output port, or kill it if port is out of range. ">checked_output_push()</a> on a pull output <em>port</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="ae6ad83314087baddd651e9a4d7dd0000"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_packet.html">Packet</a> * Element::checked_input_pull </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pull a packet from input <em>port</em>, or return 0 if <em>port</em> is out of range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>input port number</td></tr>
  </table>
  </dd>
</dl>
<p>If <em>port</em> is in range (&gt;= 0 and &lt; <a class="el" href="class_element.html#a05eb1531f95eff14e04229eb29c5b50b" title="Return the number of input ports. ">ninputs()</a>), then return the result of input(<em>port</em>).<a class="el" href="class_element.html#ace8c7b8b37f177b9a9cc024d8b64f3a3" title="Pull a packet from pull output port. ">pull()</a>. Otherwise, return null.</p>
<dl class="section note"><dt>Note</dt><dd>It is invalid to call <a class="el" href="class_element.html#ae6ad83314087baddd651e9a4d7dd0000" title="Pull a packet from input port, or return 0 if port is out of range. ">checked_input_pull()</a> on a push input <em>port</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="ad8041b7068aea6830808a42afeddfcfd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Element::class_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the element's class name. </p>
<p>Each element class must override this function to return its class name.</p>
<p>Click tools extract class names from the source. For Click to find a class name, the function definition must appear inline, on a single line, inside the element class's declaration, and must return a C string constant. It should also have public accessibility. Here's an acceptable <a class="el" href="class_element.html#ad8041b7068aea6830808a42afeddfcfd" title="Return the element&#39;s class name. ">class_name()</a> definition:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="class_element.html#ad8041b7068aea6830808a42afeddfcfd">class_name</a>()<span class="keyword"> const     </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;ARPQuerier&quot;</span>; }</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ae5b51c221451df6a3045f7e523c2e892"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * Element::port_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the element's port count specifier. </p>
<p>An element class overrides this virtual function to return a C string describing its port counts. The string gives acceptable input and output ranges, separated by a slash. Examples:</p>
<dl>
<dt><code>"1/1"</code> </dt>
<dd>The element has exactly one input port and one output port. </dd>
<dt><code>"1-2/0"</code> </dt>
<dd>One or two input ports and zero output ports. </dd>
<dt><code>"1/-6"</code> </dt>
<dd>One input port and up to six output ports. </dd>
<dt><code>"2-/-"</code> </dt>
<dd>At least two input ports and any number of output ports. </dd>
<dt><code>"3"</code> </dt>
<dd>Exactly three input and output ports. (If no slash appears, the text is used for both input and output ranges.) </dd>
<dt><code>"1-/="</code> </dt>
<dd>At least one input port and <em>the</em> <em>same</em> number of output ports. </dd>
<dt><code>"1-/=+"</code> </dt>
<dd>At least one input port and <em>one</em> <em>more</em> output port than there are input ports. </dd>
</dl>
<p><a class="el" href="class_element_1_1_port.html" title="An Element&#39;s ports. ">Port</a> counts are used to determine whether a configuration uses too few or too many ports, and lead to errors such as "'e' has no input 3" and "'e'
input 3 unused".</p>
<p>Click extracts port count specifiers from the source for use by tools. For Click to find a port count specifier, the function definition must appear inline, on a single line, inside the element class's declaration, and must return a C string constant (or a name below). It should also have public accessibility. Here's an acceptable <a class="el" href="class_element.html#ae5b51c221451df6a3045f7e523c2e892" title="Return the element&#39;s port count specifier. ">port_count()</a> definition:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="class_element.html#ae5b51c221451df6a3045f7e523c2e892">port_count</a>()<span class="keyword"> const     </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;1/1&quot;</span>; }</div>
</div><!-- fragment --><p>The default <a class="el" href="class_element.html#ae5b51c221451df6a3045f7e523c2e892" title="Return the element&#39;s port count specifier. ">port_count()</a> method returns <code>"0/0"</code>.</p>
<p>The following names are available for common port count specifiers.</p>
<ul>
<li><code>PORTS_0_0</code> for <code>"0/0"</code> </li>
<li><code>PORTS_0_1</code> for <code>"0/1"</code> </li>
<li><code>PORTS_1_0</code> for <code>"1/0"</code> </li>
<li><code>PORTS_1_1</code> for <code>"1/1"</code> </li>
<li><code>PORTS_1_1X2</code> for <code>"1/1-2"</code> </li>
</ul>
<p>Since <a class="el" href="class_element.html#ae5b51c221451df6a3045f7e523c2e892" title="Return the element&#39;s port count specifier. ">port_count()</a> should simply return a C string constant, it shouldn't matter when it's called; nevertheless, it is called before <a class="el" href="class_element.html#ab2bb58f562728df47d007fd12a9e92f4" title="Parse the element&#39;s configuration arguments. ">configure()</a>. </p>

</div>
</div>
<a class="anchor" id="aa1fc03e194bd7b55481d55b9b41b751e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * Element::processing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the element's processing specifier. </p>
<p>An element class overrides this virtual function to return a C string describing which of its ports are push, pull, or agnostic. The string gives acceptable input and output ranges, separated by a slash; the characters <code>"h"</code>, <code>"l"</code>, and <code>"a"</code> indicate push, pull, and agnostic ports, respectively. Examples:</p>
<ul>
<li><code>"h/h"</code> All input and output ports are push. </li>
<li><code>"h/l"</code> Push input ports and pull output ports. </li>
<li><code>"a/ah"</code> All input ports are agnostic. The first output port is also agnostic, but the second and subsequent output ports are push. </li>
<li><code>"hl/hlh"</code> Input port 0 and output port 0 are push. Input port 1 and output port 1 are pull. All remaining inputs are pull; all remaining outputs are push. </li>
<li><code>"a"</code> All input and output ports are agnostic. (If no slash appears, the text is used for both input and output ports.)</li>
</ul>
<p>Thus, each character indicates a single port's processing type, except that the last character in the input section is used for all remaining input ports (and similarly for outputs). It's OK to have more characters than ports; any extra characters are ignored.</p>
<p>Click extracts processing specifiers from the source for use by tools. For Click to find a processing specifier, the function definition must appear inline, on a single line, inside the element class's declaration, and must return a C string constant. It should also have public accessibility. Here's an acceptable <a class="el" href="class_element.html#aa1fc03e194bd7b55481d55b9b41b751e" title="Return the element&#39;s processing specifier. ">processing()</a> definition:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="class_element.html#aa1fc03e194bd7b55481d55b9b41b751e">processing</a>()<span class="keyword"> const     </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;a/ah&quot;</span>; }</div>
</div><!-- fragment --><p>The default <a class="el" href="class_element.html#aa1fc03e194bd7b55481d55b9b41b751e" title="Return the element&#39;s processing specifier. ">processing()</a> method returns <code>"a/a"</code>, which sets all ports to agnostic.</p>
<p>The following names are available for common processing specifiers.</p>
<ul>
<li><code>AGNOSTIC</code> for <code>"a/a"</code> </li>
<li><code>PUSH</code> for <code>"h/h"</code> </li>
<li><code>PULL</code> for <code>"l/l"</code> </li>
<li><code>PUSH_TO_PULL</code> for <code>"h/l"</code> </li>
<li><code>PULL_TO_PUSH</code> for <code>"l/h"</code> </li>
<li><code>PROCESSING_A_AH</code> for <code>"a/ah"</code> </li>
</ul>
<p>Since <a class="el" href="class_element.html#aa1fc03e194bd7b55481d55b9b41b751e" title="Return the element&#39;s processing specifier. ">processing()</a> should simply return a C string constant, it shouldn't matter when it's called; nevertheless, it is called before <a class="el" href="class_element.html#ab2bb58f562728df47d007fd12a9e92f4" title="Parse the element&#39;s configuration arguments. ">configure()</a>. </p>

</div>
</div>
<a class="anchor" id="acb359ed32700d440149ba50cea37ae8b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * Element::flow_code </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the element's internal packet flow specifier (its <em>flow code</em>). </p>
<p>An element class overrides this virtual function to return a C string describing how packets flow within the element. That is, can packets that arrive on input port X be emitted on output port Y? This information helps Click answer questions such as "What Queues are downstream of this
element?" and "Should this agnostic port be push or pull?". See below for more.</p>
<p>A flow code string consists of an input specification and an output specification, separated by a slash. Each specification is a sequence of <em>port</em> <em>codes</em>. Packets can travel from an input port to an output port only if the port codes match.</p>
<p>The simplest port code is a single case-sensitive letter. For example, the flow code <code>"x/x"</code> says that packets can travel from the element's input port to its output port, while <code>"x/y"</code> says that packets never travel between ports.</p>
<p>A port code may also be a sequence of letters in brackets, such as <code>[abz]</code>. Two port codes match iff they have at least one letter in common, so <code>[abz]</code> matches <code>a</code>, but <code>[abz]</code> and <code>[cde]</code> do not match. If a caret <code>^</code> appears after the open bracket, the port code will match all letters <em>except</em> for those after the caret. Thus, the port code <code>[^bc]</code> is equivalent to <code>[ABC...XYZadef...xyz]</code>.</p>
<p>Finally, the <code>#</code> character is also a valid port code, and may be used within brackets. One <code>#</code> matches another <code>#</code> only when they represent the same port number &ndash; for example, when one <code>#</code> corresponds to input port 2 and the other to output port 2. <code>#</code> never matches any letter. Thus, for an element with exactly 2 inputs and 2 outputs, the flow code <code>"##/##"</code> behaves like <code>"xy/xy"</code>.</p>
<p>The last code in each specification is duplicated as many times as necessary, and any extra codes are ignored. The flow codes <code>"[x#][x#][x#]/x######"</code> and <code>"[x#]/x#"</code> behave identically.</p>
<p>Here are some example flow codes.</p>
<dl>
<dt><code>"x/x"</code> </dt>
<dd><p class="startdd">Packets may travel from any input port to any output port. Most elements use this flow code.</p>
<p class="enddd"></p>
</dd>
<dt><code>"xy/x"</code> </dt>
<dd><p class="startdd">Packets arriving on input port 0 may travel to any output port, but those arriving on other input ports will not be emitted on any output. <em>ARPQuerier</em> uses this flow code.</p>
<p class="enddd"></p>
</dd>
<dt><code>"x/y"</code> </dt>
<dd><p class="startdd">Packets never travel between input and output ports. <em>Idle</em> and <em>Error</em> use this flow code. So does <em>KernelTun</em>, since its input port and output port are decoupled (packets received on its input are sent to the kernel; packets received from the kernel are sent to its output).</p>
<p class="enddd"></p>
</dd>
<dt><code>"#/#"</code> </dt>
<dd><p class="startdd">Packets arriving on input port <em>K</em> may travel only to output port <em>K</em>. <em>Suppressor</em> uses this flow code.</p>
<p class="enddd"></p>
</dd>
<dt><code>"#/[^#]"</code> </dt>
<dd><p class="startdd">Packets arriving on input port <em>K</em> may travel to any output port except <em>K</em>. <em>EtherSwitch</em> uses this flow code.</p>
<p class="enddd"></p>
</dd>
<dt><code>"xy/[xy]x"</code> </dt>
<dd><p class="startdd">Packets arriving on input port 0 may travel to any output port. <a class="el" href="class_packet.html" title="A network packet. ">Packet</a> arriving on any other input port can <em>only</em> travel to output port 0. <em>Bypass</em> uses this flow code.</p>
<p class="enddd"></p>
</dd>
</dl>
<p>Click extracts flow codes from the source for use by tools. For Click to find a flow code, the function definition must appear inline, on a single line, inside the element class's declaration, and must return a C string constant. It should also have public accessibility. Here's an acceptable <a class="el" href="class_element.html#acb359ed32700d440149ba50cea37ae8b" title="Return the element&#39;s internal packet flow specifier (its flow code). ">flow_code()</a> definition:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="class_element.html#acb359ed32700d440149ba50cea37ae8b">flow_code</a>()<span class="keyword"> const     </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;xy/x&quot;</span>; }</div>
</div><!-- fragment --><p>The default <a class="el" href="class_element.html#acb359ed32700d440149ba50cea37ae8b" title="Return the element&#39;s internal packet flow specifier (its flow code). ">flow_code()</a> method returns <code>"x/x"</code>, which indicates that packets may travel from any input to any output. This default is acceptable for the vast majority of elements.</p>
<p>The following name is available for a common flow code.</p>
<ul>
<li><code>COMPLETE_FLOW</code> for <code>"x/x"</code> </li>
</ul>
<p>Since <a class="el" href="class_element.html#acb359ed32700d440149ba50cea37ae8b" title="Return the element&#39;s internal packet flow specifier (its flow code). ">flow_code()</a> should simply return a C string constant, it shouldn't matter when it's called; nevertheless, it is called before <a class="el" href="class_element.html#ab2bb58f562728df47d007fd12a9e92f4" title="Parse the element&#39;s configuration arguments. ">configure()</a>.</p>
<h3>Determining an element's flow code</h3>
<p>To pick the right flow code for an element, consider how a flow code would affect a simple router.</p>
<p>Given an element <em>E</em> with input port <em>M</em> and output port <em>N</em>, imagine this simple configuration (or a similar configuration):</p>
<p><code>... -&gt; RED -&gt; [<em>M</em>] E [<em>N</em>] -&gt; Queue -&gt; ...;</code></p>
<p>Now, should the <em>RED</em> element include the <em>Queue</em> element in its queue length calculation? If so, then the flow code's <em>M</em>th input port code and <em>N</em>th output port code should match. If not, they shouldn't.</p>
<p>For example, consider <em>ARPQuerier's</em> second input port. On receiving an ARP response on that input, <em>ARPQuerier</em> may emit a held-over IP packet to its first output. However, a <em>RED</em> element upstream of that second input port probably wouldn't count the downstream <em>Queue</em> in its queue length calculation. After all, the ARP responses are effectively dropped; packets emitted onto the <em>Queue</em> originally came from <em>ARPQuerier's</em> first input port. Therefore, <em>ARPQuerier's</em> flow code, <code>"xy/x"</code>, specifies that packets arriving on the second input port are not emitted on any output port.</p>
<p>The <em>ARPResponder</em> element provides a contrasting example. It has one input port, which receives ARP queries, and one output port, which emits the corresponding ARP responses. A <em>RED</em> element upstream of <em>ARPResponder</em> probably <em>would</em> want to include a downstream <em>Queue</em>, since queries received by <em>ARPResponder</em> are effectively transmuted into emitted responses. Thus, <em>ARPResponder's</em> flow code, <code>"x/x"</code> (the default), specifies that packets travel through it, even though the packets it emits are completely different from the packets it receives.</p>
<p>If you find this confusing, don't fret. It is perfectly fine to be conservative when assigning flow codes, and the vast majority of the Click distribution's elements use <code>COMPLETE_FLOW</code>. </p>

</div>
</div>
<a class="anchor" id="ac3924d1c0d1e5fa7e856b20df02309a7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * Element::flags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the element's flags. </p>
<dl class="section warning"><dt>Warning</dt><dd>This interface is not stable.</dd></dl>
<p>This virtual function is called to fetch a string describing the element's flags. A flags word includes one or more space-separated flag settings, where a flag setting consists of an uppercase letter optionally followed by a number. The following flags are currently defined.</p>
<dl>
<dt><code>A</code> </dt>
<dd><p class="startdd">This element requires AlignmentInfo information. The click-align tool only generates AlignmentInfo for <code>A</code>-flagged elements.</p>
<p class="enddd"></p>
</dd>
<dt><code>S0</code> </dt>
<dd><p class="startdd">This element neither generates nor consumes packets. In other words, every packet received on its inputs will be emitted on its outputs, and every packet emitted on its outputs must have originated from its inputs. Notification uses this flag to discover certain idle paths. For example, packet schedulers (RoundRobinSched, PrioSched) never generate packets and so declare the <code>S0</code> flag. As a result, degenerate paths like "RoundRobinSched -&gt; ToDevice", where RoundRobinSched has 0 inputs, are idle rather than busy, and waste no CPU time.</p>
<p class="enddd"></p>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ab7c9264ebec07770222008dd553c8306"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Element::flag_value </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the flag value for <em>flag</em> in <a class="el" href="class_element.html#ac3924d1c0d1e5fa7e856b20df02309a7" title="Return the element&#39;s flags. ">flags()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>the flag</td></tr>
  </table>
  </dd>
</dl>
<p>Returns the numeric flag value if <em>flag</em> was specified in <a class="el" href="class_element.html#ac3924d1c0d1e5fa7e856b20df02309a7" title="Return the element&#39;s flags. ">flags()</a>, 1 if <em>flag</em> was specified without a numeric flag value, and -1 if <em>flag</em> was not specified. </p>

</div>
</div>
<a class="anchor" id="ae19904c6060f3d4411e32cba0dd2e3c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * Element::cast </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to cast the element to a named type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the type being cast to</td></tr>
  </table>
  </dd>
</dl>
<p>Click calls this function to see whether this element has a given type, identified by <em>name</em>. Thus, <a class="el" href="class_element.html#ae19904c6060f3d4411e32cba0dd2e3c1" title="Attempt to cast the element to a named type. ">cast()</a> is Click's version of the C++ <code>dynamic_cast</code> operator. (<code>dynamic_cast</code> itself is not available in the Linux kernel, so we rolled our own.) The function should return a pointer to the named object, or a null pointer if this element doesn't have that type. <em>name</em> can name an element class or another type of interface, such as <code>"Storage"</code> or Notifier::EMPTY_NOTIFIER.</p>
<p>The default implementation returns this element if <em>name</em> equals <a class="el" href="class_element.html#ad8041b7068aea6830808a42afeddfcfd" title="Return the element&#39;s class name. ">class_name()</a>, and null otherwise.</p>
<p>You should override <a class="el" href="class_element.html#ae19904c6060f3d4411e32cba0dd2e3c1" title="Attempt to cast the element to a named type. ">cast()</a> if your element inherits from another element (and you want to expose that inheritance to Click); the resulting <a class="el" href="class_element.html#ae19904c6060f3d4411e32cba0dd2e3c1" title="Attempt to cast the element to a named type. ">cast()</a> method will check both class names. For example, if element <em>Derived</em> inherited from element <em>Base</em>, Derived::cast() might be defined like this:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> *Derived::cast(<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="class_element.html#ae9d788e790a336314f3525cb4e635c1a">name</a>) {</div>
<div class="line">    <span class="keywordflow">if</span> (strcmp(name, <span class="stringliteral">&quot;Derived&quot;</span>) == 0)</div>
<div class="line">        <span class="keywordflow">return</span> (Derived *) <span class="keyword">this</span>;</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(name, <span class="stringliteral">&quot;Base&quot;</span>) == 0)</div>
<div class="line">        <span class="keywordflow">return</span> (Base *) <span class="keyword">this</span>;</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">        <span class="keywordflow">return</span> Base::cast(name);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The recursive call to Base::cast() is useful in case <em>Base</em> itself overrides <a class="el" href="class_element.html#ae19904c6060f3d4411e32cba0dd2e3c1" title="Attempt to cast the element to a named type. ">cast()</a>. The explicit check for the name <code>"Base"</code> is necessary in case <em>Base</em> did <em>not</em> override <a class="el" href="class_element.html#ae19904c6060f3d4411e32cba0dd2e3c1" title="Attempt to cast the element to a named type. ">cast()</a>: the default <a class="el" href="class_element.html#ae19904c6060f3d4411e32cba0dd2e3c1" title="Attempt to cast the element to a named type. ">cast()</a> implementation compares against <a class="el" href="class_element.html#ad8041b7068aea6830808a42afeddfcfd" title="Return the element&#39;s class name. ">class_name()</a>, which in this case is <code>"Derived"</code>. Always explicitly cast <code>this</code> to the correct type before returning it.</p>
<p>You should also override <a class="el" href="class_element.html#ae19904c6060f3d4411e32cba0dd2e3c1" title="Attempt to cast the element to a named type. ">cast()</a> if your element provides another interface, such as Storage or a <a class="el" href="class_notifier.html" title="A basic activity signal and notification provider. ">Notifier</a>.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_element.html#a8ea5fabef78987e9e6762d53e636739a" title="Attempt to cast an element&#39;s port to a named type. ">port_cast</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8ea5fabef78987e9e6762d53e636739a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * Element::port_cast </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isoutput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to cast an element's port to a named type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isoutput</td><td>false for input ports, true for output ports </td></tr>
    <tr><td class="paramname">port</td><td>port number </td></tr>
    <tr><td class="paramname">name</td><td>name of the type being cast to</td></tr>
  </table>
  </dd>
</dl>
<p>Click calls this function to see whether a port corresponds to an object of the type called <em>name</em>. The function should return a pointer to the named object, or a null pointer if this port doesn't have that type. <em>name</em> can name an element class or another type of interface, such as <code>"Storage"</code> or Notifier::EMPTY_NOTIFIER.</p>
<p>The default implementation returns the result of <a class="el" href="class_element.html#ae19904c6060f3d4411e32cba0dd2e3c1" title="Attempt to cast the element to a named type. ">cast()</a>, ignoring the <em>isoutput</em> and <em>port</em> arguments.</p>
<p>The <a class="el" href="class_element.html#ae19904c6060f3d4411e32cba0dd2e3c1" title="Attempt to cast the element to a named type. ">cast()</a> method suffices for most purposes, but some Click functionality, such as Notifiers, can use the additional precision of <a class="el" href="class_element.html#a8ea5fabef78987e9e6762d53e636739a" title="Attempt to cast an element&#39;s port to a named type. ">port_cast()</a>.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_element.html#ae19904c6060f3d4411e32cba0dd2e3c1" title="Attempt to cast the element to a named type. ">cast</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1e6b1d114dfacf402fe5066ec0f3cf92"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Element::configure_phase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the element's configure phase, which determines the order in which elements are configured and initialized. </p>
<p>Click configures and initializes elements in increasing order of <a class="el" href="class_element.html#a1e6b1d114dfacf402fe5066ec0f3cf92" title="Return the element&#39;s configure phase, which determines the order in which elements are configured and...">configure_phase()</a>. An element with configure phase 1 will always be configured (have its <a class="el" href="class_element.html#ab2bb58f562728df47d007fd12a9e92f4" title="Parse the element&#39;s configuration arguments. ">configure()</a> method called) before an element with configure phase 2. Thus, if two element classes must be configured in a given order, they should define <a class="el" href="class_element.html#a1e6b1d114dfacf402fe5066ec0f3cf92" title="Return the element&#39;s configure phase, which determines the order in which elements are configured and...">configure_phase()</a> functions to enforce that order. For example, the <em>AddressInfo</em> element defines address abbreviations for other elements to use; it should thus be configured before other elements, and its <a class="el" href="class_element.html#a1e6b1d114dfacf402fe5066ec0f3cf92" title="Return the element&#39;s configure phase, which determines the order in which elements are configured and...">configure_phase()</a> method returns a low value.</p>
<p>Configure phases should be defined relative to the following constants, which are listed in increasing order.</p>
<dl>
<dt><code>CONFIGURE_PHASE_FIRST</code> </dt>
<dd><p class="startdd">Configure before other elements. Used by <em>AddressInfo</em>.</p>
<p class="enddd"></p>
</dd>
<dt><code>CONFIGURE_PHASE_INFO</code> </dt>
<dd><p class="startdd">Configure early. Appropriate for most information elements, such as <em>ScheduleInfo</em>.</p>
<p class="enddd"></p>
</dd>
<dt><code>CONFIGURE_PHASE_PRIVILEGED</code> </dt>
<dd><p class="startdd">Intended for elements that require root privilege when run at user level, such as <em>FromDevice</em> and <em>ToDevice</em>. The <em>ChangeUID</em> element, which reliquishes root privilege, runs at configure phase <code>CONFIGURE_PHASE_PRIVILEGED</code> + 1.</p>
<p class="enddd"></p>
</dd>
<dt><code>CONFIGURE_PHASE_DEFAULT</code> </dt>
<dd><p class="startdd">The default implementation returns <code>CONFIGURE_PHASE_DEFAULT</code>, so most elements are configured at this phase. Appropriate for most elements.</p>
<p class="enddd"></p>
</dd>
<dt><code>CONFIGURE_PHASE_LAST</code> </dt>
<dd>Configure after other elements. </dd>
</dl>
<p>The body of a <a class="el" href="class_element.html#a1e6b1d114dfacf402fe5066ec0f3cf92" title="Return the element&#39;s configure phase, which determines the order in which elements are configured and...">configure_phase()</a> method should consist of a single <code>return</code> statement returning some constant. Although it shouldn't matter when it's called, it is called before <a class="el" href="class_element.html#ab2bb58f562728df47d007fd12a9e92f4" title="Parse the element&#39;s configuration arguments. ">configure()</a>. </p>

</div>
</div>
<a class="anchor" id="ab2bb58f562728df47d007fd12a9e92f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Element::configure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="class_string.html">String</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_error_handler.html">ErrorHandler</a> *&#160;</td>
          <td class="paramname"><em>errh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse the element's configuration arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>configuration arguments </td></tr>
    <tr><td class="paramname">errh</td><td>error handler</td></tr>
  </table>
  </dd>
</dl>
<p>The <a class="el" href="class_element.html#ab2bb58f562728df47d007fd12a9e92f4" title="Parse the element&#39;s configuration arguments. ">configure()</a> method is passed the element's configuration arguments. It should parse them, report any errors, and initialize the element's internal state.</p>
<p>The <em>conf</em> argument is the element's configuration string, divided into configuration arguments by splitting at commas and removing comments and leading and trailing whitespace (see <a class="el" href="confparse_8hh.html#ad6a644f412600eb0781773488c6a0046" title="Separate a configuration string into arguments at commas. ">cp_argvec()</a>). If <em>conf</em> is empty, the element was not supplied with a configuration string (or its configuration string contained only comments and whitespace). It is safe to modify <em>conf</em>; modifications will be thrown away when the function returns.</p>
<p>Any errors, warnings, or messages should be reported to <em>errh</em>. Messages need not specify the element name or type, since this information will be provided as context. <em>errh.nerrors()</em> is initially zero.</p>
<p><a class="el" href="class_element.html#ab2bb58f562728df47d007fd12a9e92f4" title="Parse the element&#39;s configuration arguments. ">configure()</a> should return a negative number if configuration fails. Returning a negative number prevents the router from initializing. The default <a class="el" href="class_element.html#ab2bb58f562728df47d007fd12a9e92f4" title="Parse the element&#39;s configuration arguments. ">configure()</a> method succeeds if and only if there are no configuration arguments.</p>
<p><a class="el" href="class_element.html#ab2bb58f562728df47d007fd12a9e92f4" title="Parse the element&#39;s configuration arguments. ">configure()</a> methods are called in order of <a class="el" href="class_element.html#a1e6b1d114dfacf402fe5066ec0f3cf92" title="Return the element&#39;s configure phase, which determines the order in which elements are configured and...">configure_phase()</a>. All elements' <a class="el" href="class_element.html#ab2bb58f562728df47d007fd12a9e92f4" title="Parse the element&#39;s configuration arguments. ">configure()</a> methods are called, even if an early <a class="el" href="class_element.html#ab2bb58f562728df47d007fd12a9e92f4" title="Parse the element&#39;s configuration arguments. ">configure()</a> method fails; this is to report all relevant error messages to the user, rather than just the first.</p>
<p><a class="el" href="class_element.html#ab2bb58f562728df47d007fd12a9e92f4" title="Parse the element&#39;s configuration arguments. ">configure()</a> is called early in the initialization process, and cannot check whether a named handler exists. That function must be left for <a class="el" href="class_element.html#abf2bbb7d3ae5a1372a6af9d7bb8269fe" title="Initialize the element. ">initialize()</a>. Assuming all router connections are valid and all <a class="el" href="class_element.html#ab2bb58f562728df47d007fd12a9e92f4" title="Parse the element&#39;s configuration arguments. ">configure()</a> methods succeed, the <a class="el" href="class_element.html#a65a2efbc7c6af095d16cf31015e9216f" title="Install the element&#39;s handlers. ">add_handlers()</a> functions will be called next.</p>
<p>A <a class="el" href="class_element.html#ab2bb58f562728df47d007fd12a9e92f4" title="Parse the element&#39;s configuration arguments. ">configure()</a> method should avoid potentially harmful actions, such as truncating files or attaching to devices. These actions should be left for the <a class="el" href="class_element.html#abf2bbb7d3ae5a1372a6af9d7bb8269fe" title="Initialize the element. ">initialize()</a> method, which is called later. This avoids harm if another element cannot be configured, or if the router is incorrectly connected, since in those cases <a class="el" href="class_element.html#abf2bbb7d3ae5a1372a6af9d7bb8269fe" title="Initialize the element. ">initialize()</a> will never be called.</p>
<p>Elements that support live reconfiguration (see <a class="el" href="class_element.html#aea3e2211f7024e49d4120ed7734f5fa9" title="Return whether an element supports live reconfiguration. ">can_live_reconfigure()</a>) should expect <a class="el" href="class_element.html#ab2bb58f562728df47d007fd12a9e92f4" title="Parse the element&#39;s configuration arguments. ">configure()</a> to be called at run time, when a user writes to the element's <code>config</code> handler. In that case, <a class="el" href="class_element.html#ab2bb58f562728df47d007fd12a9e92f4" title="Parse the element&#39;s configuration arguments. ">configure()</a> must be careful not to disturb the existing configuration unless the new configuration is error-free.</p>
<dl class="section note"><dt>Note</dt><dd>In previous releases, <a class="el" href="class_element.html#ab2bb58f562728df47d007fd12a9e92f4" title="Parse the element&#39;s configuration arguments. ">configure()</a> could not determine whether a port is push or pull or query the router for information about neighboring elements. Those functions had to be left for <a class="el" href="class_element.html#abf2bbb7d3ae5a1372a6af9d7bb8269fe" title="Initialize the element. ">initialize()</a>. Even in the current release, if any element in a configuration calls the deprecated set_ninputs() or set_noutputs() function from <a class="el" href="class_element.html#ab2bb58f562728df47d007fd12a9e92f4" title="Parse the element&#39;s configuration arguments. ">configure()</a>, then all push, pull, and neighbor information is invalidated until <a class="el" href="class_element.html#abf2bbb7d3ae5a1372a6af9d7bb8269fe" title="Initialize the element. ">initialize()</a> time.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_element.html#a56db8a2641022efc353efed36fdd73f1" title="Reconfigure the element while the router is running. ">live_reconfigure</a>, <a class="el" href="args_8hh_source.html">args.hh</a> for argument parsing </dd></dl>

</div>
</div>
<a class="anchor" id="a65a2efbc7c6af095d16cf31015e9216f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Element::add_handlers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Install the element's handlers. </p>
<p>The <a class="el" href="class_element.html#a65a2efbc7c6af095d16cf31015e9216f" title="Install the element&#39;s handlers. ">add_handlers()</a> method should install any handlers the element provides by calling <a class="el" href="class_element.html#a17b61e50a0d5c87f77606f673fe1a553" title="Register a read handler named name. ">add_read_handler()</a>, <a class="el" href="class_element.html#a277b48d1711b54532762f456b8a61218" title="Register a write handler named name. ">add_write_handler()</a>, and <a class="el" href="class_element.html#a1d54fb72aa3547cfa3095077dbdfa89c" title="Register a comprehensive handler named name. ">set_handler()</a>. These functions may also be called from <a class="el" href="class_element.html#ab2bb58f562728df47d007fd12a9e92f4" title="Parse the element&#39;s configuration arguments. ">configure()</a>, <a class="el" href="class_element.html#abf2bbb7d3ae5a1372a6af9d7bb8269fe" title="Initialize the element. ">initialize()</a>, or even later, during router execution. However, it is better in most cases to initialize handlers in <a class="el" href="class_element.html#ab2bb58f562728df47d007fd12a9e92f4" title="Parse the element&#39;s configuration arguments. ">configure()</a> or <a class="el" href="class_element.html#a65a2efbc7c6af095d16cf31015e9216f" title="Install the element&#39;s handlers. ">add_handlers()</a>, since elements that depend on other handlers often check in <a class="el" href="class_element.html#abf2bbb7d3ae5a1372a6af9d7bb8269fe" title="Initialize the element. ">initialize()</a> whether those handlers exist.</p>
<p><a class="el" href="class_element.html#a65a2efbc7c6af095d16cf31015e9216f" title="Install the element&#39;s handlers. ">add_handlers()</a> is called after <a class="el" href="class_element.html#ab2bb58f562728df47d007fd12a9e92f4" title="Parse the element&#39;s configuration arguments. ">configure()</a> and before <a class="el" href="class_element.html#abf2bbb7d3ae5a1372a6af9d7bb8269fe" title="Initialize the element. ">initialize()</a>. When it runs, it is guaranteed that every <a class="el" href="class_element.html#ab2bb58f562728df47d007fd12a9e92f4" title="Parse the element&#39;s configuration arguments. ">configure()</a> method succeeded and that all connections are correct (push and pull match up correctly and there are no unused or badly-connected ports).</p>
<p>Most <a class="el" href="class_element.html#a65a2efbc7c6af095d16cf31015e9216f" title="Install the element&#39;s handlers. ">add_handlers()</a> methods simply call <a class="el" href="class_element.html#a17b61e50a0d5c87f77606f673fe1a553" title="Register a read handler named name. ">add_read_handler()</a>, <a class="el" href="class_element.html#a277b48d1711b54532762f456b8a61218" title="Register a write handler named name. ">add_write_handler()</a>, <a class="el" href="class_element.html#aedbde0bd1c9397f4298334052a994abe" title="Register handlers for a task. ">add_task_handlers()</a>, and possibly <a class="el" href="class_element.html#a1d54fb72aa3547cfa3095077dbdfa89c" title="Register a comprehensive handler named name. ">set_handler()</a> one or more times. The default <a class="el" href="class_element.html#a65a2efbc7c6af095d16cf31015e9216f" title="Install the element&#39;s handlers. ">add_handlers()</a> method does nothing.</p>
<p>Click automatically provides five handlers for each element: <code>class</code>, <code>name</code>, <code>config</code>, <code>ports</code>, and <code>handlers</code>. There is no need to provide these yourself. </p>

</div>
</div>
<a class="anchor" id="abf2bbb7d3ae5a1372a6af9d7bb8269fe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Element::initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_error_handler.html">ErrorHandler</a> *&#160;</td>
          <td class="paramname"><em>errh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">errh</td><td>error handler</td></tr>
  </table>
  </dd>
</dl>
<p>The <a class="el" href="class_element.html#abf2bbb7d3ae5a1372a6af9d7bb8269fe" title="Initialize the element. ">initialize()</a> method is called just before the router is placed on line. It performs any final initialization, and provides the last chance to abort router installation with an error. Any errors, warnings, or messages should be reported to <em>errh</em>. Messages need not specify the element name; this information will be supplied externally. <em>errh.nerrors()</em> is initially zero.</p>
<p><a class="el" href="class_element.html#abf2bbb7d3ae5a1372a6af9d7bb8269fe" title="Initialize the element. ">initialize()</a> should return zero if initialization succeeds, or a negative number if it fails. Returning a negative number prevents the router from initializing. The default <a class="el" href="class_element.html#abf2bbb7d3ae5a1372a6af9d7bb8269fe" title="Initialize the element. ">initialize()</a> method always returns zero (success).</p>
<p><a class="el" href="class_element.html#abf2bbb7d3ae5a1372a6af9d7bb8269fe" title="Initialize the element. ">initialize()</a> methods are called in order of <a class="el" href="class_element.html#a1e6b1d114dfacf402fe5066ec0f3cf92" title="Return the element&#39;s configure phase, which determines the order in which elements are configured and...">configure_phase()</a>, using the same order as for <a class="el" href="class_element.html#ab2bb58f562728df47d007fd12a9e92f4" title="Parse the element&#39;s configuration arguments. ">configure()</a>. When an <a class="el" href="class_element.html#abf2bbb7d3ae5a1372a6af9d7bb8269fe" title="Initialize the element. ">initialize()</a> method fails, router initialization stops immediately, and no more <a class="el" href="class_element.html#abf2bbb7d3ae5a1372a6af9d7bb8269fe" title="Initialize the element. ">initialize()</a> methods are called. Thus, at most one <a class="el" href="class_element.html#abf2bbb7d3ae5a1372a6af9d7bb8269fe" title="Initialize the element. ">initialize()</a> method can fail per router configuration.</p>
<p><a class="el" href="class_element.html#abf2bbb7d3ae5a1372a6af9d7bb8269fe" title="Initialize the element. ">initialize()</a> is called after <a class="el" href="class_element.html#a65a2efbc7c6af095d16cf31015e9216f" title="Install the element&#39;s handlers. ">add_handlers()</a> and before <a class="el" href="class_element.html#abbf80c057f2d850ac85de15e22d58c52" title="Initialize the element for hotswap, where the element should take old_element&#39;s state, if possible. ">take_state()</a>. When it runs, it is guaranteed that every <a class="el" href="class_element.html#ab2bb58f562728df47d007fd12a9e92f4" title="Parse the element&#39;s configuration arguments. ">configure()</a> method succeeded, that all connections are correct (push and pull match up correctly and there are no unused or badly-connected ports), and that every <a class="el" href="class_element.html#a65a2efbc7c6af095d16cf31015e9216f" title="Install the element&#39;s handlers. ">add_handlers()</a> method has been called.</p>
<p>If every element's <a class="el" href="class_element.html#abf2bbb7d3ae5a1372a6af9d7bb8269fe" title="Initialize the element. ">initialize()</a> method succeeds, then the router is installed, and will remain installed until another router replaces it. Any errors that occur later than <a class="el" href="class_element.html#abf2bbb7d3ae5a1372a6af9d7bb8269fe" title="Initialize the element. ">initialize()</a> &ndash; during <a class="el" href="class_element.html#abbf80c057f2d850ac85de15e22d58c52" title="Initialize the element for hotswap, where the element should take old_element&#39;s state, if possible. ">take_state()</a>, <a class="el" href="class_element.html#af63395e97dd323b90d427e2eaae087eb" title="Push packet p onto push input port. ">push()</a>, or <a class="el" href="class_element.html#ace8c7b8b37f177b9a9cc024d8b64f3a3" title="Pull a packet from pull output port. ">pull()</a>, for example &ndash; will not take the router off line.</p>
<p>Strictly speaking, the only task that <em>must</em> go in <a class="el" href="class_element.html#abf2bbb7d3ae5a1372a6af9d7bb8269fe" title="Initialize the element. ">initialize()</a> is checking whether a handler exists, since that information isn't available at <a class="el" href="class_element.html#ab2bb58f562728df47d007fd12a9e92f4" title="Parse the element&#39;s configuration arguments. ">configure()</a> time. It's often convenient, however, to put other functionality in <a class="el" href="class_element.html#abf2bbb7d3ae5a1372a6af9d7bb8269fe" title="Initialize the element. ">initialize()</a>. For example, opening files for writing fits well in <a class="el" href="class_element.html#abf2bbb7d3ae5a1372a6af9d7bb8269fe" title="Initialize the element. ">initialize()</a>: if the configuration has errors before the relevant element is initialized, any existing file will be left as is. Common tasks performed in <a class="el" href="class_element.html#abf2bbb7d3ae5a1372a6af9d7bb8269fe" title="Initialize the element. ">initialize()</a> methods include:</p>
<ul>
<li>Initializing <a class="el" href="class_task.html" title="Represents a frequently-scheduled computational task. ">Task</a> objects.</li>
<li>Allocating memory.</li>
<li>Opening files.</li>
<li>Initializing network devices.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="class_element.html#abf2bbb7d3ae5a1372a6af9d7bb8269fe" title="Initialize the element. ">initialize()</a> methods may not create or destroy input and output ports, but this functionality is deprecated anyway.</dd>
<dd>
In previous releases, <a class="el" href="class_element.html#ab2bb58f562728df47d007fd12a9e92f4" title="Parse the element&#39;s configuration arguments. ">configure()</a> could not determine whether a port was push or pull or query the router for information about neighboring elements, so those tasks were relegated to <a class="el" href="class_element.html#abf2bbb7d3ae5a1372a6af9d7bb8269fe" title="Initialize the element. ">initialize()</a> methods. In the current release, <a class="el" href="class_element.html#ab2bb58f562728df47d007fd12a9e92f4" title="Parse the element&#39;s configuration arguments. ">configure()</a> can perform these tasks too. </dd></dl>

</div>
</div>
<a class="anchor" id="abbf80c057f2d850ac85de15e22d58c52"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Element::take_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_element.html">Element</a> *&#160;</td>
          <td class="paramname"><em>old_element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_error_handler.html">ErrorHandler</a> *&#160;</td>
          <td class="paramname"><em>errh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the element for hotswap, where the element should take <em>old_element's</em> state, if possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">old_element</td><td>element in the old configuration; result of <a class="el" href="class_element.html#afde7f3dce9335145efd79c0d77527768" title="Return a compatible element in the hotswap router. ">hotswap_element()</a> </td></tr>
    <tr><td class="paramname">errh</td><td>error handler</td></tr>
  </table>
  </dd>
</dl>
<p>The <a class="el" href="class_element.html#abbf80c057f2d850ac85de15e22d58c52" title="Initialize the element for hotswap, where the element should take old_element&#39;s state, if possible. ">take_state()</a> method supports hotswapping, and is the last stage of configuration installation. When a configuration is successfully installed with the hotswap option, the driver (1) stops the old configuration, (2) searches the two configurations for pairs of compatible elements, (3) calls <a class="el" href="class_element.html#abbf80c057f2d850ac85de15e22d58c52" title="Initialize the element for hotswap, where the element should take old_element&#39;s state, if possible. ">take_state()</a> on the new elements in those pairs to give them a chance to take state from the old elements, and (4) starts the new configuration.</p>
<p><a class="el" href="class_element.html#abbf80c057f2d850ac85de15e22d58c52" title="Initialize the element for hotswap, where the element should take old_element&#39;s state, if possible. ">take_state()</a> is called only when a configuration is hotswapped in. The default <a class="el" href="class_element.html#abbf80c057f2d850ac85de15e22d58c52" title="Initialize the element for hotswap, where the element should take old_element&#39;s state, if possible. ">take_state()</a> implementation does nothing; there's no need to override it unless your element has state you want preserved across hotswaps.</p>
<p>The <em>old_element</em> argument is an element from the old configuration (that is, from <a class="el" href="class_element.html#afcf3d3b03e6f24495dc92234376a7be4" title="Return the element&#39;s router. ">router()</a>-&gt;<a class="el" href="class_router.html#a0a8ff9d773631cd072c2571ec39f568c">hotswap_router()</a>) obtained by calling <a class="el" href="class_element.html#afde7f3dce9335145efd79c0d77527768" title="Return a compatible element in the hotswap router. ">hotswap_element()</a>. If <a class="el" href="class_element.html#afde7f3dce9335145efd79c0d77527768" title="Return a compatible element in the hotswap router. ">hotswap_element()</a> returns null, <a class="el" href="class_element.html#abbf80c057f2d850ac85de15e22d58c52" title="Initialize the element for hotswap, where the element should take old_element&#39;s state, if possible. ">take_state()</a> will not be called. The default <a class="el" href="class_element.html#afde7f3dce9335145efd79c0d77527768" title="Return a compatible element in the hotswap router. ">hotswap_element()</a> returns an <em>old_element</em> has the same <a class="el" href="class_element.html#ae9d788e790a336314f3525cb4e635c1a" title="Return the element&#39;s name. ">name()</a> as this element. This is often too loose; for instance, <em>old_element</em> might have a completely different class. Thus, most <a class="el" href="class_element.html#abbf80c057f2d850ac85de15e22d58c52" title="Initialize the element for hotswap, where the element should take old_element&#39;s state, if possible. ">take_state()</a> methods begin by attempting to <a class="el" href="class_element.html#ae19904c6060f3d4411e32cba0dd2e3c1" title="Attempt to cast the element to a named type. ">cast()</a> <em>old_element</em> to a compatible class, and silently returning if the result is null. Alternatively, you can override <a class="el" href="class_element.html#afde7f3dce9335145efd79c0d77527768" title="Return a compatible element in the hotswap router. ">hotswap_element()</a> and put the check there.</p>
<p>Errors and warnings should be reported to <em>errh</em>, but the router will be installed whether or not there are errors. <a class="el" href="class_element.html#abbf80c057f2d850ac85de15e22d58c52" title="Initialize the element for hotswap, where the element should take old_element&#39;s state, if possible. ">take_state()</a> should always leave this element in a state that's safe to run, and <em>old_element</em> in a state that's safe to <a class="el" href="class_element.html#aa58cba2310e9207a8afa1c5f4ecfc878" title="Clean up the element&#39;s state. ">cleanup()</a>.</p>
<p><a class="el" href="class_element.html#abbf80c057f2d850ac85de15e22d58c52" title="Initialize the element for hotswap, where the element should take old_element&#39;s state, if possible. ">take_state()</a> is called after <a class="el" href="class_element.html#abf2bbb7d3ae5a1372a6af9d7bb8269fe" title="Initialize the element. ">initialize()</a>. When it runs, it is guaranteed that this element's configuration will shortly be installed. Every <a class="el" href="class_element.html#ab2bb58f562728df47d007fd12a9e92f4" title="Parse the element&#39;s configuration arguments. ">configure()</a> and <a class="el" href="class_element.html#abf2bbb7d3ae5a1372a6af9d7bb8269fe" title="Initialize the element. ">initialize()</a> method succeeded, all connections are correct (push and pull match up correctly and there are no unused or badly-connected ports), and every <a class="el" href="class_element.html#a65a2efbc7c6af095d16cf31015e9216f" title="Install the element&#39;s handlers. ">add_handlers()</a> method has been called. It is also guaranteed that the old configuration (of which old_element is a part) had been successfully installed, but that none of its tasks are running at the moment. </p>

</div>
</div>
<a class="anchor" id="afde7f3dce9335145efd79c0d77527768"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_element.html">Element</a> * Element::hotswap_element </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a compatible element in the hotswap router. </p>
<p><a class="el" href="class_element.html#afde7f3dce9335145efd79c0d77527768" title="Return a compatible element in the hotswap router. ">hotswap_element()</a> searches the hotswap router, <a class="el" href="class_element.html#afcf3d3b03e6f24495dc92234376a7be4" title="Return the element&#39;s router. ">router()</a>-&gt;<a class="el" href="class_router.html#a0a8ff9d773631cd072c2571ec39f568c">hotswap_router()</a>, for an element compatible with this element. It returns that element, if any. If there's no compatible element, or no hotswap router, then it returns 0.</p>
<p>The default implementation searches for an element with the same name as this element. Thus, it returns 0 or an element that satisfies this constraint: <a class="el" href="class_element.html#afde7f3dce9335145efd79c0d77527768" title="Return a compatible element in the hotswap router. ">hotswap_element()</a>-&gt;<a class="el" href="class_element.html#ae9d788e790a336314f3525cb4e635c1a" title="Return the element&#39;s name. ">name()</a> == <a class="el" href="class_element.html#ae9d788e790a336314f3525cb4e635c1a" title="Return the element&#39;s name. ">name()</a>.</p>
<p>Generally, this constraint is too loose. A <em>Queue</em> element can't hotswap state from an <em>ARPResponder</em>, even if they do have the same name. Most elements also check that <a class="el" href="class_element.html#afde7f3dce9335145efd79c0d77527768" title="Return a compatible element in the hotswap router. ">hotswap_element()</a> has the right class, using the <a class="el" href="class_element.html#ae19904c6060f3d4411e32cba0dd2e3c1" title="Attempt to cast the element to a named type. ">cast()</a> function. This check can go either in <a class="el" href="class_element.html#afde7f3dce9335145efd79c0d77527768" title="Return a compatible element in the hotswap router. ">hotswap_element()</a> or in <a class="el" href="class_element.html#abbf80c057f2d850ac85de15e22d58c52" title="Initialize the element for hotswap, where the element should take old_element&#39;s state, if possible. ">take_state()</a> itself, whichever is easier; Click doesn't use the result of <a class="el" href="class_element.html#afde7f3dce9335145efd79c0d77527768" title="Return a compatible element in the hotswap router. ">hotswap_element()</a> except as an argument to <a class="el" href="class_element.html#abbf80c057f2d850ac85de15e22d58c52" title="Initialize the element for hotswap, where the element should take old_element&#39;s state, if possible. ">take_state()</a>.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_element.html#abbf80c057f2d850ac85de15e22d58c52" title="Initialize the element for hotswap, where the element should take old_element&#39;s state, if possible. ">take_state</a>, <a class="el" href="class_router.html#a0a8ff9d773631cd072c2571ec39f568c" title="Returns the currently-installed router this router will eventually replace. ">Router::hotswap_router</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa58cba2310e9207a8afa1c5f4ecfc878"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Element::cleanup </td>
          <td>(</td>
          <td class="paramtype">CleanupStage&#160;</td>
          <td class="paramname"><em>stage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clean up the element's state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage</td><td>this element's maximum initialization stage</td></tr>
  </table>
  </dd>
</dl>
<p>The <a class="el" href="class_element.html#aa58cba2310e9207a8afa1c5f4ecfc878" title="Clean up the element&#39;s state. ">cleanup()</a> method should clean up any state allocated by the initialization process. For example, it should close any open files, free up memory, and unhook from network devices. Click calls <a class="el" href="class_element.html#aa58cba2310e9207a8afa1c5f4ecfc878" title="Clean up the element&#39;s state. ">cleanup()</a> when it determines that an element's state is no longer needed, either because a router configuration is about to be removed or because the router configuration failed to initialize properly. Click will call the <a class="el" href="class_element.html#aa58cba2310e9207a8afa1c5f4ecfc878" title="Clean up the element&#39;s state. ">cleanup()</a> method exactly once on every element it creates.</p>
<p>The <em>stage</em> parameter is an enumeration constant indicating how far the element made it through the initialization process. Possible values are, in increasing order:</p>
<dl>
<dt><code>CLEANUP_BEFORE_CONFIGURE</code> </dt>
<dd><p class="startdd">The element's <a class="el" href="class_element.html#ab2bb58f562728df47d007fd12a9e92f4" title="Parse the element&#39;s configuration arguments. ">configure()</a> method was not called. This happens when some element's port counts or push/pull processing was wrong.</p>
<p class="enddd"></p>
</dd>
<dt><code>CLEANUP_CONFIGURE_FAILED</code> </dt>
<dd><p class="startdd">The element's <a class="el" href="class_element.html#ab2bb58f562728df47d007fd12a9e92f4" title="Parse the element&#39;s configuration arguments. ">configure()</a> method was called, but it failed.</p>
<p class="enddd"></p>
</dd>
<dt><code>CLEANUP_CONFIGURED</code> </dt>
<dd><p class="startdd">The element's <a class="el" href="class_element.html#ab2bb58f562728df47d007fd12a9e92f4" title="Parse the element&#39;s configuration arguments. ">configure()</a> method was called and succeeded, but its <a class="el" href="class_element.html#abf2bbb7d3ae5a1372a6af9d7bb8269fe" title="Initialize the element. ">initialize()</a> method was not called (because some other element's <a class="el" href="class_element.html#ab2bb58f562728df47d007fd12a9e92f4" title="Parse the element&#39;s configuration arguments. ">configure()</a> method failed, or there was a problem with the configuration's connections).</p>
<p class="enddd"></p>
</dd>
<dt><code>CLEANUP_INITIALIZE_FAILED</code> </dt>
<dd><p class="startdd">The element's <a class="el" href="class_element.html#ab2bb58f562728df47d007fd12a9e92f4" title="Parse the element&#39;s configuration arguments. ">configure()</a> and <a class="el" href="class_element.html#abf2bbb7d3ae5a1372a6af9d7bb8269fe" title="Initialize the element. ">initialize()</a> methods were both called. <a class="el" href="class_element.html#ab2bb58f562728df47d007fd12a9e92f4" title="Parse the element&#39;s configuration arguments. ">configure()</a> succeeded, but <a class="el" href="class_element.html#abf2bbb7d3ae5a1372a6af9d7bb8269fe" title="Initialize the element. ">initialize()</a> failed.</p>
<p class="enddd"></p>
</dd>
<dt><code>CLEANUP_INITIALIZED</code> </dt>
<dd><p class="startdd">The element's <a class="el" href="class_element.html#ab2bb58f562728df47d007fd12a9e92f4" title="Parse the element&#39;s configuration arguments. ">configure()</a> and <a class="el" href="class_element.html#abf2bbb7d3ae5a1372a6af9d7bb8269fe" title="Initialize the element. ">initialize()</a> methods were called and succeeded, but its router was never installed (because some other element's <a class="el" href="class_element.html#abf2bbb7d3ae5a1372a6af9d7bb8269fe" title="Initialize the element. ">initialize()</a> method failed).</p>
<p class="enddd"></p>
</dd>
<dt><code>CLEANUP_ROUTER_INITIALIZED</code> </dt>
<dd><p class="startdd">The element's <a class="el" href="class_element.html#ab2bb58f562728df47d007fd12a9e92f4" title="Parse the element&#39;s configuration arguments. ">configure()</a> and <a class="el" href="class_element.html#abf2bbb7d3ae5a1372a6af9d7bb8269fe" title="Initialize the element. ">initialize()</a> methods were called and succeeded, and the router of which it is a part was successfully installed.</p>
<p class="enddd"></p>
</dd>
<dt><code>CLEANUP_MANUAL</code> </dt>
<dd>Never used by Click. Intended for use when element code calls <a class="el" href="class_element.html#aa58cba2310e9207a8afa1c5f4ecfc878" title="Clean up the element&#39;s state. ">cleanup()</a> explicitly. </dd>
</dl>
<p>A configuration's <a class="el" href="class_element.html#aa58cba2310e9207a8afa1c5f4ecfc878" title="Clean up the element&#39;s state. ">cleanup()</a> methods are called in the reverse of the <a class="el" href="class_element.html#a1e6b1d114dfacf402fe5066ec0f3cf92" title="Return the element&#39;s configure phase, which determines the order in which elements are configured and...">configure_phase()</a> order used for <a class="el" href="class_element.html#ab2bb58f562728df47d007fd12a9e92f4" title="Parse the element&#39;s configuration arguments. ">configure()</a> and <a class="el" href="class_element.html#abf2bbb7d3ae5a1372a6af9d7bb8269fe" title="Initialize the element. ">initialize()</a>.</p>
<p>The default <a class="el" href="class_element.html#aa58cba2310e9207a8afa1c5f4ecfc878" title="Clean up the element&#39;s state. ">cleanup()</a> method does nothing.</p>
<p><a class="el" href="class_element.html#aa58cba2310e9207a8afa1c5f4ecfc878" title="Clean up the element&#39;s state. ">cleanup()</a> serves some of the same functions as an element's destructor. However, <a class="el" href="class_element.html#aa58cba2310e9207a8afa1c5f4ecfc878" title="Clean up the element&#39;s state. ">cleanup()</a> may be called long before an element is destroyed. Elements that are part of an erroneous router are cleaned up, but kept around for debugging purposes until another router is installed. </p>

</div>
</div>
<a class="anchor" id="a37b29a5c70f9e5b384c419bc8cb31e8a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Element::static_initialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize static data for this element class. </p>
<p>Place initialization code for an element class's shared global state in the <a class="el" href="class_element.html#a37b29a5c70f9e5b384c419bc8cb31e8a" title="Initialize static data for this element class. ">static_initialize()</a> static member function. (For example, the IPFilter element class uses <a class="el" href="class_element.html#a37b29a5c70f9e5b384c419bc8cb31e8a" title="Initialize static data for this element class. ">static_initialize()</a> to set up various parsing tables.) Click drivers will call this function when the element code is loaded, before any elements of the class are created.</p>
<p>static_initialize functions are called in an arbitrary and unpredictable order (not, for example, the <a class="el" href="class_element.html#a1e6b1d114dfacf402fe5066ec0f3cf92" title="Return the element&#39;s configure phase, which determines the order in which elements are configured and...">configure_phase()</a> order). <a class="el" href="class_element.html" title="Base class for Click elements. ">Element</a> authors are responsible for handling static initialization dependencies.</p>
<p>For Click to find a static_initialize declaration, it must appear inside the element class's class declaration on its own line and have the following prototype:</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="class_element.html#a37b29a5c70f9e5b384c419bc8cb31e8a">static_initialize</a>();</div>
</div><!-- fragment --><p>It must also have public accessibility.</p>
<dl class="section note"><dt>Note</dt><dd>In most cases you should also define a <a class="el" href="class_element.html#ac3ceb9d99079a10d4df6eb1f920a7e75" title="Clean up static data for this element class. ">static_cleanup()</a> function to clean up state initialized by <a class="el" href="class_element.html#a37b29a5c70f9e5b384c419bc8cb31e8a" title="Initialize static data for this element class. ">static_initialize()</a>.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_element.html#ac3ceb9d99079a10d4df6eb1f920a7e75" title="Clean up static data for this element class. ">Element::static_cleanup</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac3ceb9d99079a10d4df6eb1f920a7e75"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Element::static_cleanup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clean up static data for this element class. </p>
<p>Place cleanup code for an element class's shared global state in the <a class="el" href="class_element.html#ac3ceb9d99079a10d4df6eb1f920a7e75" title="Clean up static data for this element class. ">static_cleanup()</a> static member function. Click drivers will call this function before unloading the element code.</p>
<p>static_cleanup functions are called in an arbitrary and unpredictable order (not, for example, the <a class="el" href="class_element.html#a1e6b1d114dfacf402fe5066ec0f3cf92" title="Return the element&#39;s configure phase, which determines the order in which elements are configured and...">configure_phase()</a> order, and not the reverse of the static_initialize order). <a class="el" href="class_element.html" title="Base class for Click elements. ">Element</a> authors are responsible for handling static cleanup dependencies.</p>
<p>For Click to find a static_cleanup declaration, it must appear inside the element class's class declaration on its own line and have the following prototype:</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="class_element.html#ac3ceb9d99079a10d4df6eb1f920a7e75">static_cleanup</a>();</div>
</div><!-- fragment --><p>It must also have public accessibility.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_element.html#a37b29a5c70f9e5b384c419bc8cb31e8a" title="Initialize static data for this element class. ">Element::static_initialize</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae9d788e790a336314f3525cb4e635c1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_string.html">String</a> Element::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the element's name. </p>
<p>This is the name used to declare the element in the router configuration, with all compound elements expanded. </p>

</div>
</div>
<a class="anchor" id="a1d638cc353699177a9e5c06634cd5a56"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_string.html">String</a> Element::declaration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a string giving the element's name and class name. </p>
<p>neverThe result has the form "<em>name</em> :: <em>class_name"</em>. <a class="el" href="class_element.html" title="Base class for Click elements. ">Element</a> classes can override this function to supply additional important information, if desired; for example, <em>FromDump</em> returns a string "<em>name</em> :: <em>class_name</em>(<em>filename</em>)". </p>

</div>
</div>
<a class="anchor" id="afcf3d3b03e6f24495dc92234376a7be4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_router.html">Router</a> * Element::router </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the element's router. </p>

</div>
</div>
<a class="anchor" id="ae9f6ee27e9342386aaa3cb5381615cd5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Element::eindex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the element's index within its router. </p>
<dl class="section invariant"><dt>Invariant</dt><dd>this == <a class="el" href="class_element.html#afcf3d3b03e6f24495dc92234376a7be4" title="Return the element&#39;s router. ">router()</a>-&gt;element(eindex()) </dd></dl>

</div>
</div>
<a class="anchor" id="a2ea95b2e912d7d0275ddcf8d564c0644"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Element::eindex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_router.html">Router</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the element's index within router <em>r</em>. </p>
<p>Returns -1 if <em>r</em> != <a class="el" href="class_element.html#afcf3d3b03e6f24495dc92234376a7be4" title="Return the element&#39;s router. ">router()</a>. </p>

</div>
</div>
<a class="anchor" id="a7526dd9b470aa8c31ce3da9d00868d81"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Master * Element::master </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the element's master. </p>

</div>
</div>
<a class="anchor" id="a0223195c4a2b7385a0590343ef61557f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Element::nports </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isoutput</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of input or output ports. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isoutput</td><td>false for input ports, true for output ports </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a05eb1531f95eff14e04229eb29c5b50b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Element::ninputs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of input ports. </p>

</div>
</div>
<a class="anchor" id="a3b909f7829ff14f5b1dd4165580f69f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Element::noutputs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of output ports. </p>

</div>
</div>
<a class="anchor" id="a397a2f89d50f1656b4d7c0334fa2747c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_element_1_1_port.html">Element::Port</a> &amp; Element::port </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isoutput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return one of the element's ports. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isoutput</td><td>false for input ports, true for output ports </td></tr>
    <tr><td class="paramname">port</td><td>port number</td></tr>
  </table>
  </dd>
</dl>
<p>An assertion fails if <em>p</em> is out of range. </p>

</div>
</div>
<a class="anchor" id="a526e36b67e098181d2b3232193427b27"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_element_1_1_port.html">Element::Port</a> &amp; Element::input </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return one of the element's input ports. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>port number</td></tr>
  </table>
  </dd>
</dl>
<p>An assertion fails if <em>port</em> is out of range.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_element_1_1_port.html" title="An Element&#39;s ports. ">Port</a>, <a class="el" href="class_element.html#a397a2f89d50f1656b4d7c0334fa2747c" title="Return one of the element&#39;s ports. ">port</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3b3d622841bb29ee99da17ddba88a471"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_element_1_1_port.html">Element::Port</a> &amp; Element::output </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return one of the element's output ports. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>port number</td></tr>
  </table>
  </dd>
</dl>
<p>An assertion fails if <em>port</em> is out of range.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_element_1_1_port.html" title="An Element&#39;s ports. ">Port</a>, <a class="el" href="class_element.html#a397a2f89d50f1656b4d7c0334fa2747c" title="Return one of the element&#39;s ports. ">port</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a38a57625b6c72bef7d3372d0cbb1340e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Element::port_active </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isoutput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether a port is active. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isoutput</td><td>false for input ports, true for output ports </td></tr>
    <tr><td class="paramname">port</td><td>port number</td></tr>
  </table>
  </dd>
</dl>
<p>Returns true iff <em>port</em> is in range and <em>port</em> is active. Push outputs and pull inputs are active; pull outputs and push inputs are not.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_element_1_1_port.html#a680e253829636a8741c77e1952789a89" title="Returns whether this port is active (a push output or a pull input). ">Element::Port::active</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a008593f424c28ff3383f48171a55f9aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Element::input_is_push </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether input <em>port</em> is push. </p>
<p>Returns true iff input <em>port</em> exists and is push. </p>

</div>
</div>
<a class="anchor" id="adc88cf11558b6c2c020169c264f2a9d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Element::input_is_pull </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether input <em>port</em> is pull. </p>
<p>Returns true iff input <em>port</em> exists and is pull. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_element.html#a38a57625b6c72bef7d3372d0cbb1340e" title="Check whether a port is active. ">port_active</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5d7fcf6ec9c04da9ed44944cad797906"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Element::output_is_push </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether output <em>port</em> is push. </p>
<p>Returns true iff output <em>port</em> exists and is push. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_element.html#a38a57625b6c72bef7d3372d0cbb1340e" title="Check whether a port is active. ">port_active</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae5f05a099134956c439e0dbd9185b882"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Element::output_is_pull </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether output <em>port</em> is pull. </p>
<p>Returns true iff output <em>port</em> exists and is pull. </p>

</div>
</div>
<a class="anchor" id="aea87a4b450501ba8bde14d4431ea7e92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Element::port_flow </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isoutput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bitvector.html">Bitvector</a> *&#160;</td>
          <td class="paramname"><em>travels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analyze internal packet flow with respect to port <em>p</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">isoutput</td><td>false for input ports, true for output ports </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">p</td><td>port number </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">travels</td><td>the bitvector to initialize with internal packet flow information</td></tr>
  </table>
  </dd>
</dl>
<p>Analyzes the element's <a class="el" href="class_element.html#acb359ed32700d440149ba50cea37ae8b" title="Return the element&#39;s internal packet flow specifier (its flow code). ">flow_code()</a> and determines how packets might travel from the specified port. The <em>travels</em> bitvector is initialized to have one entry per complementary port; thus, if <em>isoutput</em> is true, then <em>travels</em> has <a class="el" href="class_element.html#a05eb1531f95eff14e04229eb29c5b50b" title="Return the number of input ports. ">ninputs()</a> entries. The entry for port <em>x</em> is set to true iff packets can travel from <em>p</em> to <em>x</em>. Returns all false if <em>p</em> is out of range.</p>
<p>For example, if <a class="el" href="class_element.html#acb359ed32700d440149ba50cea37ae8b" title="Return the element&#39;s internal packet flow specifier (its flow code). ">flow_code()</a> is "xy/xxyx", and the element has 2 inputs and 4 outputs, then:</p>
<ul>
<li>port_flow(false, 0, travels) returns [true, true, false, true]</li>
<li>port_flow(false, 1, travels) returns [false, false, true, false]</li>
<li>port_flow(true, 0, travels) returns [true, false]</li>
</ul>
<p>Uses an element's overridden flow code when one is supplied; see <a class="el" href="class_router.html#a89d7b1d04892b41e393372edc6756266" title="Returns the overriding flow code for element e, if any. ">Router::flow_code_override()</a>.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_element.html#acb359ed32700d440149ba50cea37ae8b" title="Return the element&#39;s internal packet flow specifier (its flow code). ">flow_code</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4c909e3f64f1104e0c70a5acc53166a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_string.html">String</a> Element::configuration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the element's current configuration string. </p>
<p>The configuration string is obtained by calling the element's "config" read handler. The default read handler calls <a class="el" href="class_router.html#ad616383b1878cd5261ec68086720bb73" title="Returns element index eindex&#39;s configuration string. ">Router::econfiguration()</a>. </p>

</div>
</div>
<a class="anchor" id="aea3e2211f7024e49d4120ed7734f5fa9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Element::can_live_reconfigure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return whether an element supports live reconfiguration. </p>
<p>Returns true iff this element can be reconfigured as the router is running. Click will make the element's "config" handler writable if <a class="el" href="class_element.html#aea3e2211f7024e49d4120ed7734f5fa9" title="Return whether an element supports live reconfiguration. ">can_live_reconfigure()</a> returns true; when that handler is written, Click will call the element's <a class="el" href="class_element.html#a56db8a2641022efc353efed36fdd73f1" title="Reconfigure the element while the router is running. ">live_reconfigure()</a> function. The default implementation returns false. </p>

</div>
</div>
<a class="anchor" id="a56db8a2641022efc353efed36fdd73f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Element::live_reconfigure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="class_string.html">String</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_error_handler.html">ErrorHandler</a> *&#160;</td>
          <td class="paramname"><em>errh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reconfigure the element while the router is running. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>configuration arguments </td></tr>
    <tr><td class="paramname">errh</td><td>error handler</td></tr>
  </table>
  </dd>
</dl>
<p>This function should parse the configuration arguments in <em>conf</em>, set the element's state accordingly, and report any error messages or warnings to <em>errh</em>. This resembles <a class="el" href="class_element.html#ab2bb58f562728df47d007fd12a9e92f4" title="Parse the element&#39;s configuration arguments. ">configure()</a>. However, <a class="el" href="class_element.html#a56db8a2641022efc353efed36fdd73f1" title="Reconfigure the element while the router is running. ">live_reconfigure()</a> is called when the element's "config" handler is written, rather than at router initialization time. Thus, the element already has a working configuration. If <em>conf</em> has an error, <a class="el" href="class_element.html#a56db8a2641022efc353efed36fdd73f1" title="Reconfigure the element while the router is running. ">live_reconfigure()</a> should leave this previous working configuration alone.</p>
<p><a class="el" href="class_element.html#aea3e2211f7024e49d4120ed7734f5fa9" title="Return whether an element supports live reconfiguration. ">can_live_reconfigure()</a> must return true for <a class="el" href="class_element.html#a56db8a2641022efc353efed36fdd73f1" title="Reconfigure the element while the router is running. ">live_reconfigure()</a> to work.</p>
<p>Return &gt;= 0 on success, &lt; 0 on error. On success, Click will set the element's old configuration arguments to <em>conf</em>, so that later reads of the "config" handler will return <em>conf</em>. (An element can override this by defining its own "config" handler.)</p>
<p>The default implementation simply calls configure(<em>conf</em>, <em>errh</em>). This is OK as long as <a class="el" href="class_element.html#ab2bb58f562728df47d007fd12a9e92f4" title="Parse the element&#39;s configuration arguments. ">configure()</a> doesn't change the element's state on error.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_element.html#aea3e2211f7024e49d4120ed7734f5fa9" title="Return whether an element supports live reconfiguration. ">can_live_reconfigure</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a941698f9fa2b91f6e795a05497e18b49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_router_thread.html">RouterThread</a> * Element::home_thread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the element's home thread. </p>

</div>
</div>
<a class="anchor" id="a7ed6015f3a12301042b6abcdcc6d082d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Element::add_select </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register interest in <em>mask</em> events on file descriptor <em>fd</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>the file descriptor </td></tr>
    <tr><td class="paramname">mask</td><td>relevant events: bitwise-or of one or more of SELECT_READ, SELECT_WRITE</td></tr>
  </table>
  </dd>
</dl>
<p>Click will register interest in readability and/or writability on file descriptor <em>fd</em>. When <em>fd</em> is ready, Click will call this element's selected(<em>fd</em>, <em>mask</em>) method.</p>
<p>add_select(<em>fd</em>, <em>mask</em>) overrides any previous <a class="el" href="class_element.html#a7ed6015f3a12301042b6abcdcc6d082d" title="Register interest in mask events on file descriptor fd. ">add_select()</a> for the same <em>fd</em> and events in <em>mask</em>. However, different elements may register interest in different events for the same <em>fd</em>.</p>
<dl class="section note"><dt>Note</dt><dd>Only available at user level.</dd>
<dd>
Selecting for writability with SELECT_WRITE normally requires more care than selecting for readability with SELECT_READ. You should add_select(<em>fd</em>, SELECT_WRITE) only when there is data to write to <em>fd</em>. Otherwise, Click will constantly poll your element's selected(<em>fd</em>, <em>mask</em>) method.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_element.html#a7c789f9051b016234f5f6c02dc8243fa" title="Remove interest in mask events on file descriptor fd. ">remove_select</a>, <a class="el" href="class_element.html#aa98e97859a6506f467fa6cb6a276c1f3" title="Handle a file descriptor event. ">selected</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7c789f9051b016234f5f6c02dc8243fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Element::remove_select </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove interest in <em>mask</em> events on file descriptor <em>fd</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>the file descriptor </td></tr>
    <tr><td class="paramname">mask</td><td>relevant events: bitwise-or of one or more of SELECT_READ, SELECT_WRITE</td></tr>
  </table>
  </dd>
</dl>
<p>Click will remove any existing <a class="el" href="class_element.html#a7ed6015f3a12301042b6abcdcc6d082d" title="Register interest in mask events on file descriptor fd. ">add_select()</a> registrations for readability and/or writability on file descriptor <em>fd</em>. The named events on <em>fd</em> will no longer cause a <a class="el" href="class_element.html#aa98e97859a6506f467fa6cb6a276c1f3" title="Handle a file descriptor event. ">selected()</a> call.</p>
<dl class="section note"><dt>Note</dt><dd>Only available at user level.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_element.html#a7ed6015f3a12301042b6abcdcc6d082d" title="Register interest in mask events on file descriptor fd. ">add_select</a>, <a class="el" href="class_element.html#aa98e97859a6506f467fa6cb6a276c1f3" title="Handle a file descriptor event. ">selected</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a17b61e50a0d5c87f77606f673fe1a553"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Element::add_read_handler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadHandlerCallback&#160;</td>
          <td class="paramname"><em>read_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>user_data</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a read handler named <em>name</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>handler name </td></tr>
    <tr><td class="paramname">read_callback</td><td>function called when handler is read </td></tr>
    <tr><td class="paramname">user_data</td><td>user data parameter passed to <em>read_callback</em> </td></tr>
    <tr><td class="paramname">flags</td><td>flags to set</td></tr>
  </table>
  </dd>
</dl>
<p>Adds a read handler named <em>name</em> for this element. Reading the handler returns the result of the <em>read_callback</em> function, which is called like this:</p>
<div class="fragment"><div class="line"><a class="code" href="class_string.html">String</a> result = read_callback(e, user_data);</div>
</div><!-- fragment --><p><em>e</em> is this element pointer.</p>
<p>add_read_handler(<em>name</em>) overrides any previous add_read_handler(<em>name</em>) or set_handler(<em>name</em>), but any previous add_write_handler(<em>name</em>) remains in effect.</p>
<p>The added read handler takes no parameters. To create a read handler with parameters, use <a class="el" href="class_element.html#a1d54fb72aa3547cfa3095077dbdfa89c" title="Register a comprehensive handler named name. ">set_handler()</a> or <a class="el" href="class_element.html#a8eca02ee2bbc0c5c0b031cc542da234c" title="Set flags for the handler named name. ">set_handler_flags()</a>.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_element.html#ad1a8c339915279661504132604484e7b" title="Standard read handler returning a positional argument. ">read_positional_handler</a>, <a class="el" href="class_element.html#abc959b669793b2925854ba2a5e6760d6" title="Standard read handler returning a keyword argument. ">read_keyword_handler</a>: standard read handler callback functions </dd>
<dd>
<a class="el" href="class_element.html#a277b48d1711b54532762f456b8a61218" title="Register a write handler named name. ">add_write_handler</a>, <a class="el" href="class_element.html#a1d54fb72aa3547cfa3095077dbdfa89c" title="Register a comprehensive handler named name. ">set_handler</a>, <a class="el" href="class_element.html#aedbde0bd1c9397f4298334052a994abe" title="Register handlers for a task. ">add_task_handlers</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3c183575db52b821054a8e1d36383695"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Element::add_read_handler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadHandlerCallback&#160;</td>
          <td class="paramname"><em>read_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a read handler named <em>name</em>. </p>
<p>This version of <a class="el" href="class_element.html#a17b61e50a0d5c87f77606f673fe1a553" title="Register a read handler named name. ">add_read_handler()</a> is useful when <em>user_data</em> is an integer. Note that the <em>read_callback</em> function must still cast its <code>void *</code> argument to <code>intptr_t</code> to obtain the integer value. </p>

</div>
</div>
<a class="anchor" id="ae0dd551b17d084eb0665f135f11a0ae5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Element::add_read_handler </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadHandlerCallback&#160;</td>
          <td class="paramname"><em>read_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>user_data</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a read handler named <em>name</em>. </p>
<p>This version of <a class="el" href="class_element.html#a17b61e50a0d5c87f77606f673fe1a553" title="Register a read handler named name. ">add_read_handler()</a> is useful when <em>name</em> is a static constant string. <em>name</em> is passed to <a class="el" href="class_string.html#a595465bb6ea95f1d8bdfefc611711863" title="Return a String that directly references the C string cstr. ">String::make_stable</a>. The memory referenced by <em>name</em> must remain valid for as long as the router containing this element. </p>

</div>
</div>
<a class="anchor" id="a277b48d1711b54532762f456b8a61218"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Element::add_write_handler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteHandlerCallback&#160;</td>
          <td class="paramname"><em>write_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>user_data</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a write handler named <em>name</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>handler name </td></tr>
    <tr><td class="paramname">write_callback</td><td>function called when handler is written </td></tr>
    <tr><td class="paramname">user_data</td><td>user data parameter passed to <em>write_callback</em> </td></tr>
    <tr><td class="paramname">flags</td><td>flags to set</td></tr>
  </table>
  </dd>
</dl>
<p>Adds a write handler named <em>name</em> for this element. Writing the handler calls the <em>write_callback</em> function like this:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> r = write_callback(data, e, user_data, errh);</div>
</div><!-- fragment --><p><em>e</em> is this element pointer. The return value <em>r</em> should be negative on error, positive or zero on success. Any messages should be reported to the <em>errh</em> <a class="el" href="class_error_handler.html" title="Error reporting class. ">ErrorHandler</a> object.</p>
<p>add_write_handler(<em>name</em>) overrides any previous add_write_handler(<em>name</em>) or set_handler(<em>name</em>), but any previous add_read_handler(<em>name</em>) remains in effect.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_element.html#a1b6ab2cdc14122476473eb3baf5791f7" title="Standard write handler for reconfiguring an element by changing one of its positional arguments...">reconfigure_positional_handler</a>, <a class="el" href="class_element.html#a821ac1ae1b0879239be4895f8e211a54" title="Standard write handler for reconfiguring an element by changing one of its keyword arguments...">reconfigure_keyword_handler</a>: standard write handler callback functions </dd>
<dd>
<a class="el" href="class_element.html#a17b61e50a0d5c87f77606f673fe1a553" title="Register a read handler named name. ">add_read_handler</a>, <a class="el" href="class_element.html#a1d54fb72aa3547cfa3095077dbdfa89c" title="Register a comprehensive handler named name. ">set_handler</a>, <a class="el" href="class_element.html#aedbde0bd1c9397f4298334052a994abe" title="Register handlers for a task. ">add_task_handlers</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a458209eff42e3a8cf2ac228f6ac23104"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Element::add_write_handler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteHandlerCallback&#160;</td>
          <td class="paramname"><em>write_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a write handler named <em>name</em>. </p>
<p>This version of <a class="el" href="class_element.html#a277b48d1711b54532762f456b8a61218" title="Register a write handler named name. ">add_write_handler()</a> is useful when <em>user_data</em> is an integer. Note that the <em>write_callback</em> function must still cast its <code>void *</code> argument to <code>intptr_t</code> to obtain the integer value. </p>

</div>
</div>
<a class="anchor" id="a166c05b2674d0eedfdf187690d6a8dd9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Element::add_write_handler </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteHandlerCallback&#160;</td>
          <td class="paramname"><em>write_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>user_data</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a write handler named <em>name</em>. </p>
<p>This version of <a class="el" href="class_element.html#a277b48d1711b54532762f456b8a61218" title="Register a write handler named name. ">add_write_handler()</a> is useful when <em>name</em> is a static constant string. <em>name</em> is passed to <a class="el" href="class_string.html#a595465bb6ea95f1d8bdfefc611711863" title="Return a String that directly references the C string cstr. ">String::make_stable</a>. The memory referenced by <em>name</em> must remain valid for as long as the router containing this element. </p>

</div>
</div>
<a class="anchor" id="a1d54fb72aa3547cfa3095077dbdfa89c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Element::set_handler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HandlerCallback&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>read_user_data</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>write_user_data</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a comprehensive handler named <em>name</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>handler name </td></tr>
    <tr><td class="paramname">flags</td><td>handler flags </td></tr>
    <tr><td class="paramname">callback</td><td>function called when handler is written </td></tr>
    <tr><td class="paramname">read_user_data</td><td>read user data parameter stored in the handler </td></tr>
    <tr><td class="paramname">write_user_data</td><td>write user data parameter stored in the handler</td></tr>
  </table>
  </dd>
</dl>
<p>Registers a comprehensive handler named <em>name</em> for this element. The handler handles the operations specified by <em>flags</em>, which can include <a class="el" href="class_handler.html#ac08417becc781346bef93d6dd440bc55a53839db78e8b48bd46beb3d8cff3f2d3" title="Handler supports read operations. ">Handler::f_read</a>, <a class="el" href="class_handler.html#ac08417becc781346bef93d6dd440bc55affb8316da8ea607553b43f123b3d6403" title="Handler supports write operations. ">Handler::f_write</a>, <a class="el" href="class_handler.html#ac08417becc781346bef93d6dd440bc55ac5d9adb323bbd4707eef4cca0553c8e1" title="Read handler takes parameters. ">Handler::f_read_param</a>, and others. Reading the handler calls the <em>callback</em> function like this:</p>
<div class="fragment"><div class="line"><a class="code" href="class_string.html">String</a> data;</div>
<div class="line"><span class="keywordtype">int</span> r = callback(<a class="code" href="class_handler.html#ac08417becc781346bef93d6dd440bc55a53839db78e8b48bd46beb3d8cff3f2d3">Handler::f_read</a>, data, e, h, errh);</div>
</div><!-- fragment --><p>Writing the handler calls it like this:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> r = callback(<a class="code" href="class_handler.html#ac08417becc781346bef93d6dd440bc55affb8316da8ea607553b43f123b3d6403">Handler::f_write</a>, data, e, h, errh);</div>
</div><!-- fragment --><p><em>e</em> is this element pointer, and <em>h</em> points to the <a class="el" href="class_handler.html" title="Represents a router&#39;s handlers. ">Handler</a> object for this handler. The <em>data</em> string is an out parameter for reading and an in parameter for writing; when reading with parameters, <em>data</em> has the parameters on input and should be replaced with the result on output. The return value <em>r</em> should be negative on error, positive or zero on success. Any messages should be reported to the <em>errh</em> <a class="el" href="class_error_handler.html" title="Error reporting class. ">ErrorHandler</a> object.</p>
<p>set_handler(<em>name</em>) overrides any previous add_read_handler(<em>name</em>), add_write_handler(<em>name</em>), or set_handler(<em>name</em>). </p>

</div>
</div>
<a class="anchor" id="ace0cebeb4e2fb6c105292ce44e7d191f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Element::set_handler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HandlerCallback&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>read_user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>write_user_data</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a comprehensive handler named <em>name</em>. </p>
<p>This version of <a class="el" href="class_element.html#a1d54fb72aa3547cfa3095077dbdfa89c" title="Register a comprehensive handler named name. ">set_handler()</a> is useful when <em>user_data</em> is an integer. Note that the <a class="el" href="class_handler.html#ac3087d4c0aedbb8ec7bd363e149bc869" title="Return this handler&#39;s callback data. ">Handler::user_data()</a> methods still return <code>void *</code> values. </p>

</div>
</div>
<a class="anchor" id="af60c267d804237970b7066fd51abaef3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Element::set_handler </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HandlerCallback&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>read_user_data</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>write_user_data</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a comprehensive handler named <em>name</em>. </p>
<p>This version of <a class="el" href="class_element.html#a1d54fb72aa3547cfa3095077dbdfa89c" title="Register a comprehensive handler named name. ">set_handler()</a> is useful when <em>name</em> is a static constant string. <em>name</em> is passed to <a class="el" href="class_string.html#a595465bb6ea95f1d8bdfefc611711863" title="Return a String that directly references the C string cstr. ">String::make_stable</a>. The memory referenced by <em>name</em> must remain valid for as long as the router containing this element. </p>

</div>
</div>
<a class="anchor" id="a8eca02ee2bbc0c5c0b031cc542da234c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Element::set_handler_flags </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>set_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>clear_flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set flags for the handler named <em>name</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>handler name </td></tr>
    <tr><td class="paramname">set_flags</td><td>handler flags to set </td></tr>
    <tr><td class="paramname">clear_flags</td><td>handler flags to clear</td></tr>
  </table>
  </dd>
</dl>
<p>Sets flags for any handlers named <em>name</em> for this element. Fails if no <em>name</em> handler exists. </p>

</div>
</div>
<a class="anchor" id="aedbde0bd1c9397f4298334052a994abe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Element::add_task_handlers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_task.html">Task</a> *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_notifier_signal.html">NotifierSignal</a> *&#160;</td>
          <td class="paramname"><em>signal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>prefix</em> = <code><a class="el" href="class_string.html">String</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register handlers for a task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td><a class="el" href="class_task.html" title="Represents a frequently-scheduled computational task. ">Task</a> object </td></tr>
    <tr><td class="paramname">signal</td><td>optional <a class="el" href="class_notifier_signal.html" title="An activity signal. ">NotifierSignal</a> object </td></tr>
    <tr><td class="paramname">flags</td><td>defines handlers to install </td></tr>
    <tr><td class="paramname">prefix</td><td>prefix for each handler</td></tr>
  </table>
  </dd>
</dl>
<p>Adds a standard set of handlers for the task. They can include:</p>
<ul>
<li>A "scheduled" read handler, which returns <code>true</code> if the task is scheduled and <code>false</code> if not. </li>
<li>A "scheduled" write handler, which accepts a Boolean and unschedules or reschedules the task as appropriate. </li>
<li>A "tickets" read handler, which returns the task's tickets. </li>
<li>A "tickets" write handler to set the task's tickets. </li>
<li>A "home_thread" read handler, which returns the task's home thread ID. </li>
<li>A "home_thread" write handler, which sets the task's home thread ID.</li>
</ul>
<p>The <em>flags</em> argument controls which handlers are installed. By default, this is all but the the "scheduled" write handler. Individual flags are:</p>
<ul>
<li>TASKHANDLER_WRITE_SCHEDULED: A "scheduled" write handler. </li>
<li>TASKHANDLER_WRITE_TICKETS: A "tickets" write handler. </li>
<li>TASKHANDLER_WRITE_HOME_THREAD: A "home_thread" write handler. </li>
<li>TASKHANDLER_WRITE_ALL: All available write handlers. </li>
<li>TASKHANDLER_DEFAULT: Equals TASKHANDLER_WRITE_TICKETS | TASKHANDLER_WRITE_HOME_THREAD.</li>
</ul>
<p>Depending on Click's configuration options, some of these handlers might not be available. If Click was configured with schedule debugging, the "scheduled" read handler will additionally report whether an unscheduled task is pending, and a "notifier" read handler will report the state of the <em>signal</em>, if any.</p>
<p>Each handler name is prefixed with the <em>prefix</em> string, so an element with multiple <a class="el" href="class_task.html" title="Represents a frequently-scheduled computational task. ">Task</a> objects can register handlers for each of them.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_element.html#a17b61e50a0d5c87f77606f673fe1a553" title="Register a read handler named name. ">add_read_handler</a>, <a class="el" href="class_element.html#a277b48d1711b54532762f456b8a61218" title="Register a write handler named name. ">add_write_handler</a>, <a class="el" href="class_element.html#a1d54fb72aa3547cfa3095077dbdfa89c" title="Register a comprehensive handler named name. ">set_handler</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a837de440df86cf088e14142ecb1b26c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Element::add_data_handlers </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register read and/or write handlers accessing <em>data</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>handler name </td></tr>
    <tr><td class="paramname">flags</td><td>handler flags, containing at least one of <a class="el" href="class_handler.html#ac08417becc781346bef93d6dd440bc55a53839db78e8b48bd46beb3d8cff3f2d3" title="Handler supports read operations. ">Handler::f_read</a> and <a class="el" href="class_handler.html#ac08417becc781346bef93d6dd440bc55affb8316da8ea607553b43f123b3d6403" title="Handler supports write operations. ">Handler::f_write</a> </td></tr>
    <tr><td class="paramname">data</td><td>pointer to data</td></tr>
  </table>
  </dd>
</dl>
<p>Registers read and/or write handlers named <em>name</em> for this element. If (<em>flags</em> &amp; <a class="el" href="class_handler.html#ac08417becc781346bef93d6dd440bc55a53839db78e8b48bd46beb3d8cff3f2d3" title="Handler supports read operations. ">Handler::f_read</a>), registers a read handler; if (<em>flags</em> &amp; <a class="el" href="class_handler.html#ac08417becc781346bef93d6dd440bc55affb8316da8ea607553b43f123b3d6403" title="Handler supports write operations. ">Handler::f_write</a>), registers a write handler. These handlers read or set the data stored at <em>*data</em>, which might, for example, be an element instance variable. This data is unparsed and/or parsed using the expected functions; for example, the <code>bool</code> version uses BoolArg::unparse() and BoolArg::parse(). <em>name</em> is passed to <a class="el" href="class_string.html#a595465bb6ea95f1d8bdfefc611711863" title="Return a String that directly references the C string cstr. ">String::make_stable</a>. The memory referenced by <em>name</em> must remain valid for as long as the router containing this element.</p>
<p>Overloaded versions of this function are available for many fundamental data types. </p>

</div>
</div>
<a class="anchor" id="aafe3c05c39e6011878b97fb695e26e89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Element::add_data_handlers </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a918dbca1f74786143db5ce22ba36dae5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Element::add_data_handlers </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a6465366d667eb4f37681119093eb9c67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Element::add_data_handlers </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a61fc8b2548ceb3b3ccdba2a5c0fe78e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Element::add_data_handlers </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="aa351db1c26ae9226ecae40514158ed2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Element::add_data_handlers </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classatomic__uint32__t.html">atomic_uint32_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a6e6275e9870024735b8c8a263211b382"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Element::add_data_handlers </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a7a230f229edd9f19104679c95a04abc8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Element::add_data_handlers </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="aa6de35fe05cfb0538205833043acc4c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Element::add_net_order_data_handlers </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register read and/or write handlers accessing <em>data</em> in network byte order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>handler name </td></tr>
    <tr><td class="paramname">flags</td><td>handler flags, containing at least one of <a class="el" href="class_handler.html#ac08417becc781346bef93d6dd440bc55a53839db78e8b48bd46beb3d8cff3f2d3" title="Handler supports read operations. ">Handler::f_read</a> and <a class="el" href="class_handler.html#ac08417becc781346bef93d6dd440bc55affb8316da8ea607553b43f123b3d6403" title="Handler supports write operations. ">Handler::f_write</a> </td></tr>
    <tr><td class="paramname">data</td><td>pointer to data</td></tr>
  </table>
  </dd>
</dl>
<p>Registers read and/or write handlers named <em>name</em> for this element. If (<em>flags</em> &amp; <a class="el" href="class_handler.html#ac08417becc781346bef93d6dd440bc55a53839db78e8b48bd46beb3d8cff3f2d3" title="Handler supports read operations. ">Handler::f_read</a>), registers a read handler; if (<em>flags</em> &amp; <a class="el" href="class_handler.html#ac08417becc781346bef93d6dd440bc55affb8316da8ea607553b43f123b3d6403" title="Handler supports write operations. ">Handler::f_write</a>), registers a write handler. These handlers read or set the data stored at <em>*data</em>, which might, for example, be an element instance variable. </p>

</div>
</div>
<a class="anchor" id="ace8d4f1a3763729961e4ab84ed4a7dce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Element::add_net_order_data_handlers </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="ab5af24565484eef392bd1a808ed3c9e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Element::add_data_handlers </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="ad8d06b77d29e5d199410c0ad7f8419a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Element::add_data_handlers </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_string.html">String</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register read and/or write handlers accessing <em>data</em>. </p>
<p>This function's read handler returns *<em>data</em> unchanged, and its write handler sets *<em>data</em> to the input string as received, without unquoting or removing leading and trailing whitespace. </p>

</div>
</div>
<a class="anchor" id="a21152aa5d1e8557ebb8168fb6cdd70c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Element::add_data_handlers </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_p_address.html">IPAddress</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a7c3eca9a77a2443b7ef43dedb292bda9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Element::add_data_handlers </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ether_address.html">EtherAddress</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a1f661ec13f3319da730eeb78db77c38e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Element::add_data_handlers </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_timestamp.html">Timestamp</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_interval</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register read and/or write handlers accessing <em>data</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>handler name </td></tr>
    <tr><td class="paramname">flags</td><td>handler flags, containing at least one of <a class="el" href="class_handler.html#ac08417becc781346bef93d6dd440bc55a53839db78e8b48bd46beb3d8cff3f2d3" title="Handler supports read operations. ">Handler::f_read</a> and <a class="el" href="class_handler.html#ac08417becc781346bef93d6dd440bc55affb8316da8ea607553b43f123b3d6403" title="Handler supports write operations. ">Handler::f_write</a> </td></tr>
    <tr><td class="paramname">data</td><td>pointer to data </td></tr>
    <tr><td class="paramname">is_interval</td><td>If true, the read handler unparses *<em>data</em> as an interval. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad1a8c339915279661504132604484e7b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_string.html">String</a> Element::read_positional_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_element.html">Element</a> *&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Standard read handler returning a positional argument. </p>
<p>Use this function to define a handler that returns one of an element's positional configuration arguments. The <em>thunk</em> argument is a typecast integer that specifies which one. For instance, to add "first", "second", and "third" read handlers that return the element's first three configuration arguments:</p>
<div class="fragment"><div class="line"><a class="code" href="class_element.html#a17b61e50a0d5c87f77606f673fe1a553">add_read_handler</a>(<span class="stringliteral">&quot;first&quot;</span>, <a class="code" href="class_element.html#ad1a8c339915279661504132604484e7b">read_positional_handler</a>, 0);</div>
<div class="line"><a class="code" href="class_element.html#a17b61e50a0d5c87f77606f673fe1a553">add_read_handler</a>(<span class="stringliteral">&quot;second&quot;</span>, <a class="code" href="class_element.html#ad1a8c339915279661504132604484e7b">read_positional_handler</a>, 1);</div>
<div class="line"><a class="code" href="class_element.html#a17b61e50a0d5c87f77606f673fe1a553">add_read_handler</a>(<span class="stringliteral">&quot;third&quot;</span>, <a class="code" href="class_element.html#ad1a8c339915279661504132604484e7b">read_positional_handler</a>, 2);</div>
</div><!-- fragment --><p>Returns the empty string if there aren't enough arguments.</p>
<dl class="section warning"><dt>Warning</dt><dd>Prefer <a class="el" href="class_element.html#abc959b669793b2925854ba2a5e6760d6" title="Standard read handler returning a keyword argument. ">read_keyword_handler()</a> to <a class="el" href="class_element.html#ad1a8c339915279661504132604484e7b" title="Standard read handler returning a positional argument. ">read_positional_handler()</a>.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_element.html#a4c909e3f64f1104e0c70a5acc53166a0" title="Return the element&#39;s current configuration string. ">configuration</a>: used to obtain the element's current <a class="el" href="class_element.html#a4c909e3f64f1104e0c70a5acc53166a0" title="Return the element&#39;s current configuration string. ">configuration</a>. </dd>
<dd>
<a class="el" href="class_element.html#abc959b669793b2925854ba2a5e6760d6" title="Standard read handler returning a keyword argument. ">read_keyword_handler</a>, <a class="el" href="class_element.html#a1b6ab2cdc14122476473eb3baf5791f7" title="Standard write handler for reconfiguring an element by changing one of its positional arguments...">reconfigure_positional_handler</a>, <a class="el" href="class_element.html#a17b61e50a0d5c87f77606f673fe1a553" title="Register a read handler named name. ">add_read_handler</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abc959b669793b2925854ba2a5e6760d6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_string.html">String</a> Element::read_keyword_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_element.html">Element</a> *&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Standard read handler returning a keyword argument. </p>
<p>Use this function to define a handler that returns one of an element's keyword configuration arguments. The <em>user_data</em> argument is a C string that specifies which one. For instance, to add a "data" read handler that returns the element's "DATA" keyword argument:</p>
<div class="fragment"><div class="line"><a class="code" href="class_element.html#a17b61e50a0d5c87f77606f673fe1a553">add_read_handler</a>(<span class="stringliteral">&quot;data&quot;</span>, <a class="code" href="class_element.html#abc959b669793b2925854ba2a5e6760d6">read_keyword_handler</a>, <span class="stringliteral">&quot;DATA&quot;</span>);</div>
</div><!-- fragment --><p>Returns the empty string if the configuration doesn't have the specified keyword.</p>
<p>The keyword might have been passed as a mandatory positional argument. Click will find it anyway if you prefix the keyword name with the mandatory position. For example, this tells reconfigure_keyword_handler to use the first positional argument for "DATA" if the keyword itself is missing:</p>
<div class="fragment"><div class="line"><a class="code" href="class_element.html#a277b48d1711b54532762f456b8a61218">add_write_handler</a>(<span class="stringliteral">&quot;data&quot;</span>, <a class="code" href="class_element.html#a821ac1ae1b0879239be4895f8e211a54">reconfigure_keyword_handler</a>, <span class="stringliteral">&quot;0 DATA&quot;</span>);</div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_element.html#a4c909e3f64f1104e0c70a5acc53166a0" title="Return the element&#39;s current configuration string. ">configuration</a>: used to obtain the element's current <a class="el" href="class_element.html#a4c909e3f64f1104e0c70a5acc53166a0" title="Return the element&#39;s current configuration string. ">configuration</a>. </dd>
<dd>
<a class="el" href="class_element.html#ad1a8c339915279661504132604484e7b" title="Standard read handler returning a positional argument. ">read_positional_handler</a>, <a class="el" href="class_element.html#a821ac1ae1b0879239be4895f8e211a54" title="Standard write handler for reconfiguring an element by changing one of its keyword arguments...">reconfigure_keyword_handler</a>, <a class="el" href="class_element.html#a17b61e50a0d5c87f77606f673fe1a553" title="Register a read handler named name. ">add_read_handler</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1b6ab2cdc14122476473eb3baf5791f7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Element::reconfigure_positional_handler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_element.html">Element</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_error_handler.html">ErrorHandler</a> *&#160;</td>
          <td class="paramname"><em>errh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Standard write handler for reconfiguring an element by changing one of its positional arguments. </p>
<dl class="section warning"><dt>Warning</dt><dd>Prefer <a class="el" href="class_element.html#a821ac1ae1b0879239be4895f8e211a54" title="Standard write handler for reconfiguring an element by changing one of its keyword arguments...">reconfigure_keyword_handler()</a> to <a class="el" href="class_element.html#a1b6ab2cdc14122476473eb3baf5791f7" title="Standard write handler for reconfiguring an element by changing one of its positional arguments...">reconfigure_positional_handler()</a>.</dd></dl>
<p>Use this function to define a handler that, when written, reconfigures an element by changing one of its positional arguments. The <em>user_data</em> argument is a typecast integer that specifies which one. For typecast integer that specifies which one. For instance, to add "first", "second", and "third" write handlers that change the element's first three configuration arguments:</p>
<div class="fragment"><div class="line"><a class="code" href="class_element.html#a277b48d1711b54532762f456b8a61218">add_write_handler</a>(<span class="stringliteral">&quot;first&quot;</span>, <a class="code" href="class_element.html#a1b6ab2cdc14122476473eb3baf5791f7">reconfigure_positional_handler</a>, 0);</div>
<div class="line"><a class="code" href="class_element.html#a277b48d1711b54532762f456b8a61218">add_write_handler</a>(<span class="stringliteral">&quot;second&quot;</span>, <a class="code" href="class_element.html#a1b6ab2cdc14122476473eb3baf5791f7">reconfigure_positional_handler</a>, 1);</div>
<div class="line"><a class="code" href="class_element.html#a277b48d1711b54532762f456b8a61218">add_write_handler</a>(<span class="stringliteral">&quot;third&quot;</span>, <a class="code" href="class_element.html#a1b6ab2cdc14122476473eb3baf5791f7">reconfigure_positional_handler</a>, 2);</div>
</div><!-- fragment --><p>When one of these handlers is written, Click will call the element's <a class="el" href="class_element.html#a4c909e3f64f1104e0c70a5acc53166a0" title="Return the element&#39;s current configuration string. ">configuration()</a> method to obtain the element's current configuration, change the relevant argument, and call <a class="el" href="class_element.html#a56db8a2641022efc353efed36fdd73f1" title="Reconfigure the element while the router is running. ">live_reconfigure()</a> to reconfigure the element.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_element.html#a4c909e3f64f1104e0c70a5acc53166a0" title="Return the element&#39;s current configuration string. ">configuration</a>: used to obtain the element's current <a class="el" href="class_element.html#a4c909e3f64f1104e0c70a5acc53166a0" title="Return the element&#39;s current configuration string. ">configuration</a>. </dd>
<dd>
<a class="el" href="class_element.html#a56db8a2641022efc353efed36fdd73f1" title="Reconfigure the element while the router is running. ">live_reconfigure</a>: used to reconfigure the element. </dd>
<dd>
<a class="el" href="class_element.html#a821ac1ae1b0879239be4895f8e211a54" title="Standard write handler for reconfiguring an element by changing one of its keyword arguments...">reconfigure_keyword_handler</a>, <a class="el" href="class_element.html#ad1a8c339915279661504132604484e7b" title="Standard read handler returning a positional argument. ">read_positional_handler</a>, <a class="el" href="class_element.html#a277b48d1711b54532762f456b8a61218" title="Register a write handler named name. ">add_write_handler</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a821ac1ae1b0879239be4895f8e211a54"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Element::reconfigure_keyword_handler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_element.html">Element</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_error_handler.html">ErrorHandler</a> *&#160;</td>
          <td class="paramname"><em>errh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Standard write handler for reconfiguring an element by changing one of its keyword arguments. </p>
<p>Use this function to define a handler that, when written, reconfigures an element by changing one of its keyword arguments. The <em>thunk</em> argument is a C string that specifies which one. For typecast integer that specifies which one. For instance, to add a "data" write handler that changes the element's "DATA" configuration argument:</p>
<div class="fragment"><div class="line"><a class="code" href="class_element.html#a277b48d1711b54532762f456b8a61218">add_write_handler</a>(<span class="stringliteral">&quot;data&quot;</span>, <a class="code" href="class_element.html#a821ac1ae1b0879239be4895f8e211a54">reconfigure_keyword_handler</a>, <span class="stringliteral">&quot;DATA&quot;</span>);</div>
</div><!-- fragment --><p>When this handler is written, Click will obtain the element's current configuration, remove any previous occurrences of the keyword, add the new keyword argument to the end, and call <a class="el" href="class_element.html#a56db8a2641022efc353efed36fdd73f1" title="Reconfigure the element while the router is running. ">live_reconfigure()</a> to reconfigure the element.</p>
<p>The keyword might have been passed as a mandatory positional argument. Click will find it anyway if you prefix the keyword name with the mandatory position. For example, this tells reconfigure_keyword_handler to use the first positional argument for "DATA" if the keyword itself is missing:</p>
<div class="fragment"><div class="line"><a class="code" href="class_element.html#a277b48d1711b54532762f456b8a61218">add_write_handler</a>(<span class="stringliteral">&quot;data&quot;</span>, <a class="code" href="class_element.html#a821ac1ae1b0879239be4895f8e211a54">reconfigure_keyword_handler</a>, <span class="stringliteral">&quot;0 DATA&quot;</span>);</div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_element.html#a4c909e3f64f1104e0c70a5acc53166a0" title="Return the element&#39;s current configuration string. ">configuration</a>: used to obtain the element's current <a class="el" href="class_element.html#a4c909e3f64f1104e0c70a5acc53166a0" title="Return the element&#39;s current configuration string. ">configuration</a>. </dd>
<dd>
<a class="el" href="class_element.html#a56db8a2641022efc353efed36fdd73f1" title="Reconfigure the element while the router is running. ">live_reconfigure</a>: used to reconfigure the element. </dd>
<dd>
<a class="el" href="class_element.html#a1b6ab2cdc14122476473eb3baf5791f7" title="Standard write handler for reconfiguring an element by changing one of its positional arguments...">reconfigure_positional_handler</a>, <a class="el" href="class_element.html#abc959b669793b2925854ba2a5e6760d6" title="Standard read handler returning a keyword argument. ">read_keyword_handler</a>, <a class="el" href="class_element.html#a277b48d1711b54532762f456b8a61218" title="Register a write handler named name. ">add_write_handler</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a167cc0ddc82c96e127a039e31168546c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Element::llrpc </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handle a low-level remote procedure call. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">command</td><td>command number </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>pointer to any data for the command </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&gt;= 0 on success, &lt; 0 on failure</dd></dl>
<p>Low-level RPCs are a lightweight mechanism for communicating between user-level programs and a Click kernel module, although they're also available in user-level Click. Rather than open a file, write ASCII data to the file, and close it, as for handlers, the user-level program calls <code>ioctl()</code> on an open file. Click intercepts the <code>ioctl</code> and calls the <a class="el" href="class_element.html#a167cc0ddc82c96e127a039e31168546c" title="Handle a low-level remote procedure call. ">llrpc()</a> method, passing it the <code>ioctl</code> number and the associated <em>data</em> pointer. The <a class="el" href="class_element.html#a167cc0ddc82c96e127a039e31168546c" title="Handle a low-level remote procedure call. ">llrpc()</a> method should read and write <em>data</em> as appropriate. <em>data</em> may be either a kernel pointer (i.e., directly accessible) or a user pointer (i.e., requires special macros to access), depending on the LLRPC number; see &lt;<a class="el" href="llrpc_8h_source.html">click/llrpc.h</a>&gt; for more.</p>
<p>A negative return value is interpreted as an error and returned to the user in <code>errno</code>. Overriding implementations should handle <em>commands</em> they understand as appropriate, and call their parents' <a class="el" href="class_element.html#a167cc0ddc82c96e127a039e31168546c" title="Handle a low-level remote procedure call. ">llrpc()</a> method to handle any other commands. The default implementation simply returns <code>-EINVAL</code>.</p>
<p>Click elements should never call each other's <a class="el" href="class_element.html#a167cc0ddc82c96e127a039e31168546c" title="Handle a low-level remote procedure call. ">llrpc()</a> methods directly; use <a class="el" href="class_element.html#af13791d53b74844a08ffe4c1ba771b81" title="Execute an LLRPC from within the configuration. ">local_llrpc()</a> instead. </p>

</div>
</div>
<a class="anchor" id="af13791d53b74844a08ffe4c1ba771b81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Element::local_llrpc </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute an LLRPC from within the configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">command</td><td>command number </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>pointer to any data for the command</td></tr>
  </table>
  </dd>
</dl>
<p>Call this function to execute an element's LLRPC from within another element's code. It executes any setup code necessary to initialize memory state, then calls <a class="el" href="class_element.html#a167cc0ddc82c96e127a039e31168546c" title="Handle a low-level remote procedure call. ">llrpc()</a>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/click/<a class="el" href="element_8hh_source.html">element.hh</a></li>
<li>include/click/<a class="el" href="master_8hh_source.html">master.hh</a></li>
<li>lib/element.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 15 2018 22:13:46 for Click by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
